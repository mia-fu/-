[TOC]

## 一、数据库基本概念

### 1. 说说主键、外键、超键、候选键

<details>
<summary>主键</summary>
   	<p>
        数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。场景：在学生表中，我们常常将学号设为主键，主键不能为空，而且能唯一标识这个学生
    </p>   
</details>

<details>
<summary>外键</summary>
   	<p>
        在一个表中存在的另一个表的主键称此表的外键。
    </p>   
</details>

<details>
<summary>超键</summary>
   	<p>
        在关系中能<b>唯一标识</b>元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。场景：学号唯一，是一个超键。（姓名，学号）唯一，这也是一个超键
    </p>   
</details>

<details>
<summary>候选键</summary>
   	<p>
        是最小超键，即没有冗余元素的超键。场景：学生表中的(学号,学号）可以确定一个学生，但是一个身份证号就能确定这个学生了，所以(学号,学号）不是候选键
    </p>   
</details>


### 2. SQL语言分类

<details>
<summary>SQL语言共分为四大类</summary>
   	<li>数据查询语言DQL</li>
    <li>数据操纵语言DML</li>
    <li>数据定义语言DDL</li>
    <li>数据控制语言DCL。</li>
</details>

<details>
<summary>1. 数据查询语言DQL</summary>
   	<p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p>
    <li>SELECT</li>
    <li>FROM</li>
    <li>WHERE</li>
</details>

<details>
<summary>2. 数据操纵语言DML</summary>
   	<p>
        数据操纵语言DML主要有三种形式：
    </p>
    <li>插入：INSERT</li>
    <li>更新：UPDATE</li>
    <li>删除：DELETE</li>
</details>

<details>
<summary>3. 数据定义语言DDL</summary>
   	<p>
        数据定义语言DDL用来创建数据库中的各种对象-----表、视图、索引、同义词、聚簇等如：
    </p>
    <li>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</li>
    <li>----------表---视图---索引---同义词---簇</li>
    <li>DDL操作是隐性提交的！不能rollback</li>
</details>

<details>
<summary>4. 数据控制语言DCL</summary>
   	<p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
    <li>GRANT：授权。</li>
    <li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚---ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：
SQL>ROLLBACK;</li>
    <li>COMMIT [WORK]：提交。</li>
</details>





### 3. 提交数据的三种类型

> 在数据库的插入、删除和修改操作时，只有当事务在提交到数据
> 库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看
> 到所做的事情，别人只有在最后提交完成后才可以看到。

<details>
<summary>显式提交</summary>
   	<p>
        用COMMIT命令直接完成的提交为显式提交。其格式为：
SQL>COMMIT；
    </p>
</details>

<details>
<summary>隐式提交</summary>
   	<p>
        用SQL命令间接完成的提交为隐式提交。这些命令是：
    </p>
    <p>
		ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，
EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。
    </p>
</details>
<details>
<summary>自动提交</summary>
   	<p>
        若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，
系统将自动进行提交，这就是自动提交。其格式为：
    </p>
    <p>
		SQL>SET AUTOCOMMIT ON；
    </p>
</details>



参考文章：
<https://www.cnblogs.com/study-s/p/5287529.html>



### 4. 触发器的作用？

<details>
<summary>展开查看</summary>
    <li>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。</li>
    <li>它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。</li>
    <li>可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</li>
</details>



### 5. 什么是存储过程？用什么来调用？

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

**调用：**

1）可以用一个命令对象来调用存储过程。

2）可以供外部程序调用，比如：java程序。



### 6. 存储过程的优缺点？

<details>
<summary>优点</summary>
   	<li>1）存储过程是预编译过的，执行效率高。</li>  
    <li>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
    <li>3）安全性高，执行存储过程需要有一定权限的用户。</li>
    <li>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</li>
</details>

<details>
<summary>缺点</summary>
   	<li>移植性差</li>
</details>





### 7. 什么叫视图？游标是什么？

<details>
<summary>视图</summary>
   	<li>是一种虚拟的表，具有和物理表相同的功能。</li>  
    <li>可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。<b>对视图的修改会影响基本表</b>。它使得我们获取数据更容易，相比多表查询。</li>
</details>

<details>
<summary>游标</summary>
   	<li>是对查询出来的结果集作为一个单元来有效的处理。</li>  
    <li>游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。</li>
    <li>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</li>
</details>



### 8. 视图的优缺点

<details>
<summary>优点</summary>
   	<li>1)对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</li>  
    <li>2)用户通过简单的查询可以从复杂查询中得到结果。</li>
    <li>3)维护数据的独立性，试图可从多个表检索数据。</li>
    <li>4)对于相同的数据可产生不同的视图。</li>
</details>

<details>
<summary>缺点</summary>
   	<li>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</li>
</details>





### 9. drop、truncate、 delete区别

<details>
<summary>最基本</summary>
    <li>drop直接删掉表。</li>
    <li>truncate删除表中数据，再插入时自增长id又从1开始。</li>
    <li>delete删除表中数据，可以加where字句。</li>

<details>
<summary>drop</summary>
    <li>删除内容和定义，释放空间。（表结构和数据一同删除）</li>
    <li>TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li>
    <li>truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</li>
    <li><code>drop table user;</code></li>

<details>
<summary>truncate</summary>
    <li>删除内容，释放空间，但不删除定义。（表结构还在，数据删除）</li>
    <li>表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</li>
    <li>truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</li>
    <li><code>truncate table user;</code></li>
</details>

<details>
<summary>delete</summary>
    <li>删除内容，不删除定义，也不释放空间。</li>
    <li>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</li>
    <li>应用范围：TRUNCATE 只能对TABLE；DELETE可以是table和view</li>
    <li>delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</li>
    <li>delete删除表中数据，可以加where字句。</li>
    <li><code>delete from user;</code></li>
**三者的执行速度，一般来说：drop > truncate > delete**



### 10. 什么是临时表，临时表什么时候删除?

<details>
<summary>展开查看</summary>
    <li>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。</li>
    <li>因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。</li>
    <li>创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</li>
</details>

临时表可以手动删除：

```mysql
DROP TEMPORARY TABLE IF EXISTS temp_tb;
```

创建临时表：

```mysql
CREATE TEMPORARY TABLE tmp_table (

NAME VARCHAR (10) NOT NULL,

time date NOT NULL
);

select * from tmp_table;
```





### 11. 非关系型数据库和关系型数据库区别，优势比较?

<details>
<summary>非关系型数据库</summary>
    <li>性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
    <li>可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
</details>

<details>
<summary>关系型数据库</summary>
    <li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
    <li>事务支持：使得对于安全性能很高的数据访问要求得以实现。</li>
</details>

<details>
<summary>其他</summary>
    <li>对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</li>
    <li>NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</li>
    <li>对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</li>
</details>





### 12. 数据库的范式？

[可以看看知乎的数据库范式回答](<https://www.zhihu.com/question/24696366>)								

<details>
<summary>第一范式</summary>
    <li>(确保每列保持原子性)<b>所有字段值都是不可分解的原子值。</b></li>
    <li>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</li>
    <li>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式。</li>
</details>

<details>
<summary>第二范式</summary>
    <li>(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li>
    <li><b>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖</b></li>
    <li>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</li>
    <li>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li>
    <li>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</li>
</details>
<details>
<summary>第三范式</summary>
    <li>(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</li>
    <li>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</li>
    <li>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段</li>
</details>

<details>
<summary>BC范式</summary>
    <li>符合3NF，并且，主属性不依赖于主属性。</li>
    <li>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。</li>
    <li>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。</li>
    <li>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。</li>
    <li>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。</li>
    <li>一般，一个数据库设计符合3NF或BCNF就可以了。</li>
</details>

<details>
<summary>第四范式</summary>
    <li>符合3NF，并且，主属性不依赖于主属性。</li>
    <li>要求把同一表内的多对多关系删除。</li>
</details>

<details>
<summary>第五范式</summary>
    <li>从最终结构重新建立原始结构。</li>
    <li>要求把同一表内的多对多关系删除。</li>
</details>



### 13. 什么是 内连接、外连接、交叉连接、笛卡尔积等?

<details>
<summary>内连接</summary>
    <li>从只连接匹配的行</li>
</details>

![内连接](https://s1.ax1x.com/2020/03/30/GupgfA.png)

<details>
<summary>左外连接</summary>
    <li>包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</li>
</details>

![](https://s1.ax1x.com/2020/03/30/GupDeO.png)



<details>
<summary>右外连接</summary>
    <li>包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</li>
</details>

![](https://s1.ax1x.com/2020/03/30/GupHYj.png)

例如1：
SELECT a.*,b.* FROM luntan LEFT JOIN usertable as b ON a.username=b.username

例如2：
SELECT a.*,b.* FROM city as a FULL OUTER JOIN user as b ON a.username=b.username

<details>
<summary>全外连接</summary>
    <li>包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</li>
</details>

![](https://s1.ax1x.com/2020/03/30/Gu99k4.png)



<details>
<summary>交叉连接</summary>
    <li>生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</li>
</details>

例如：
SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type



注意：

很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：

[牛客网数据库SQL实战](https://www.nowcoder.com/ta/sql)



### 14. varchar和char的使用场景?

<details>
<summary>展开查看</summary>
    <li>1. char的长度是不可变的，而varchar的长度是可变的。</li>
    <p>
        定义一个char[10]和varchar[10]。如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。
    </p>
    <li>2. char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。</li>
    <p>
        char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。varchar是以空间效率为首位。
    </p>
    <li>3. char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</li>
    <p>
        varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。
    </p>
    <li>4. 两者的存储数据都非unicode的字符数据。</li>
</details>





### 15. like % 和 _ 的区别

- 通配符的分类:

1. **%百分号通配符:**表示任何字符出现任意次数(可以是0次).

2. **_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.

3. **like操作符:** LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.

**注意:** 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,
```mysql
SELECT * FROM products WHERE products.prod_name like '1000';
```
只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.

* % 通配符使用: 

1. 匹配以"Li"开头的记录:(包括记录"Li") :
 ```mysql
SELECT *FROM products WHERE products.prod_name like 'Li%';
 ```
2. 匹配包含"Li"的记录(包括记录"Li") :
```mysql
SELECT* FROM products WHERE products.prod_name like '%Li%';
```
3. 匹配以"Li"结尾的记录(包括记录"Li",不包括记录"Li ",也就是Li后面有空格的记录,这里需要注意) :
```mysql
SELECT * FROM products WHERE products.prod_name like '%Li';
```

* _ 通配符使用: 

```mysql
SELECT FROM products WHERE products.prod_name like '_Li'; 
```
匹配结果为: 像`"xLi"`这样记录.
```mysql
SELECT FROM products WHERE products.prod_name like 'Li**'; 
```
匹配结果为: 像"Lixx"这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)

**注意事项:**

- 注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像`liyue`这样记录是不能被`"Li__"`这样的匹配条件匹配的.
- 注意尾部空格,`"%Li"`是不能匹配`"Li "`这样的记录的.
- 注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说
  `SELECT * FROM products WHERE products.prod_name like '%;`
  是匹配不到`products.prod_name`为NULL的的记录.


正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。使用通配符时要注意的事情：
1. 不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。
2. 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。
3. 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.





### 16. count(\*)、count(1)、count(column_name)的区别

<details>
<summary>展开查看</summary>
    <li>count(*)对行的数目进行计算,包含NULL</li>
    <li>count(column_name)对特定的列的值具有的行数进行计算,不包含NULL值。</li>
    <li>count(1)与count（*）执行结果一致，不会忽略列值为NULL的情况； </li>
</details>


### 17. E-R模型

#### 定义

> E-R模型即实体-关系数据模型，用于数据库设计
>
> 用简单的E-R图反映了现实世界中存在的事物或数据以及他们之间的关系

* 实体

  1. 描述客观事务的概念
  2. 表示方法：矩形框
  3. 示例：一个人、一本书、一杯咖啡、一个学生

* 属性

  1. 实体具有的某种特性

  2. 表示方法：椭圆形

  3. 示例：

     学生属性：学号、姓名、年龄、性别、专业...

     感受属性：悲伤、喜悦、刺激、愤怒...

#### 关系

1. 实体之间的关系

2. 一对一关联（1：1）：老公对老婆

   A中的一个实体，B中只能有一个实体与其发生关联

   B中的一个实体，A中只能有一个实体与其发生关联

3. 一对多关联（1：n）：父亲对孩子

   A中的一个实体，B中有多个实体与其发生关联

   B中的一个实体，A中只能有一个实体与其发生关联

4. 多对多关联（m：n）：兄弟姐妹对兄弟姐妹、学生对课程

   A中的一个实体，B中有多个实体与其发生关联

   B中的一个实体，A中有多个实体与其发生关联

#### E-R图

**矩形框代表实体,菱形框代表关系,椭圆形代表属性**







### 18. 数据库建表要考虑什么

1. 给表建立主键，看到好多表没主键，这在查询和索引定义上将有一定的影响
2. 表中数据类型。使用varchar，代替char
3. 避免表字段运行为null
4. 如何建立索引
5. 大数据字段最好剥离出单独的表，以便影响性能



### 19. 什么是视图？什么是游标？

* 视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能
* 游标是对查询出来的结果集作为一个单元来有效的处理。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。






## 二、事务

###  1. 什么是事务（概念）？

<details>
<summary>展开查看</summary>
    <p>
        事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束
    </p>
</details>



### 2. 事务的四大特性

<details>
<summary>展开查看</summary>
    <li>原子性（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作<b>要么全部提交成功，要么全部失败回滚</b>（用回滚日志实现，反向执行日志中的操作）；</li>
    <li>一致性（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；场景：比如A向B转账，不可能A扣了钱，B却没收到。</li>
    <li>隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；场景：A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</li>
    <li>持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的。即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</details>



### 3. 会出现哪些并发一致性问题？

> 从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。

<details>
<summary>展开查看</summary>
    <li>丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
    <li>脏读（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的，造成两个事务得到的数据不一致；</li>
    <li>不可重复读（Nonrepeatable Read）：在⼀个事务A中多次操作数据， 在事务操作过程中(未最终提交)，事务B才做了处理， 并且该值发生了改变， 这时候就会导致A在事务操作的时候， 发现数据与第⼀次不⼀样了。 <b>（你读取过的数据，再次读取出来发现值不一样了。）</b>就是不可重复读。
此情况仅会发⽣在： 读未提交、 读提交的隔离级别.</li>
    <li>幻读（Phantom Read）：它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样。<b>（同样的条件，第1次和第2次读出来的记录数不一样。）</b></li>
    <li>注意：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</li>
</details>




### 4. 数据库的四种隔离级别

<details>
<summary>展开查看</summary>
    <li>读未提交（Read Uncommited）：⼀个事务还没提交时， 它做的变更就能被别的事务看到。<b>会导致脏读、不可重复读、幻读</b>；</li>
    <li>读提交（Read Commited）：⼀个事务提交之后， 它做的变更才会被其他事务看到。<b>可避免脏读问题</b>；</li>
    <li>可重复读（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。<b>可避免不可重复读</b>；</li>
    <li>可串行化（Serializable）：强制事务串行执行， “写”会加“写锁”， “读”会加“读锁”。 使之不可能相互冲突，从而<b>解决幻读问题</b>。可能导致大量的超时现象和锁竞争，实际很少使用。</li>
</details>

<details>
<summary>简单理解</summary>
    <li>读未提交（Read Uncommited）：别⼈改数据的事务尚未提交， 我在我的事务中也能读到。</li>
    <li>读提交（Read Commited）：别⼈改数据的事务已经提交， 我在我的事务中才能读到。</li>
    <li>可重复读（Repeatable Read）：别⼈改数据的事务已经提交， 我在我的事务中也不去读。</li>
    <li>我的事务尚未提交， 别人就别想改数据。</li>
    <li>这4种隔离级别， 并行性能依次降低， 安全性依次提高。</li>
</details>


### 5. MySQL默认是哪个隔离级别?

<details>
<summary>展开查看</summary>
    <li>MySQL默认的事务隔离级别为repeatable-read</li>
    <li>MySQL 支持 4 中事务隔离级别.</li>
    <li>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</li>
    <li>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</li>
    <li>事务隔离级别：未提交读时，写数据只会锁住相应的行。</li>
	<li>事务隔离级别为：可重复读时，写数据会锁住整张表。</li>
	<li>事务隔离级别为：串行化时，读写数据都会锁住整张表。</li>
    <li>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以<b>优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。</b>尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</li>
</details>



### 6. 什么是嵌套事务？

<details>
<summary>展开查看</summary>
    <li>嵌套是子事务套在父事务中执行，<b>子事务是父事务的一部分</b>，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。</li>
</details>

<details>
<summary>如果子事务回滚，会发生什么？</summary>
    <li>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</li>
</details>

<details>
<summary>如果父事务回滚，会发生什么？</summary>
    <li>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。</li>
</details>

<details>
<summary>事务的提交，是什么情况？</summary>
    <li>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交</li>
</details>







## 三、数据库锁

### 1. MySQL三种锁的级别

<details>
<summary>展开查看</summary>
    <li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
    <li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
    <li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</details>




### 2. 什么是乐观锁和悲观锁？

<details>
<summary>展开查看</summary>
    <li>悲观锁：认为数据随时会被修改（被害妄想症），因此<b>每次读取数据之前都会上锁，防止其它事务读取或修改数据</b>（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）；应用于数据更新比较频繁的场景；传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
    <li>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改（天真），<b>操作数据时不会上锁</b>，但是<b>更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试</b>；适用于读多写少的场景。</li>
    <ol>
        乐观锁的实现方式有：
        <li>版本号机制：加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li>
    	<li>CAS算法：compare and swap（比较与交换），是一种有名的无锁算法。<b>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。</b>一般情况下是一个自旋操作，即不断的重试</li>
    </ol>
</details>



### 3. 常见的封锁类型？

<details>
<summary>展开查看</summary>
    <ul>1. 排它锁（Exclusive Lock）/ X锁
        <li>事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；</li>
    </ul>
    <ul>2. 共享锁（Shared Lock）/ S锁
        <li>加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁</li>
        <li>场景：相当于对于同一把门，它拥有多个钥匙一样。</li>
        <li>在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。</li>
    </ul>
    <ul>3. 意向锁（Intention Locks）：
    <li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；</li>
        <li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；</li>
        <li>IS/IX 锁之间都是兼容的；</li>
        <li>好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了</li>
    </ul>
</details>

锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性

<details>
<summary>封锁粒度的概念</summary>
    <p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。（行级锁的封锁粒度小）</p>
    <p>
        表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
    <p>
        行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
    </p>
    </p>
    <p>
        封锁粒度小：
        <li>好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高；</li>
        <li>坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）</li>
    </p>
</details>

<details>
<summary>MySQL加锁</summary>
    <pre>
    <code>SELECT ... LOCK In SHARE MODE;
     SELECT ... FOR UPDATE;</code>
    </pre>
</details>



### 4. 什么是三级封锁协议？

<details>
<summary>展开查看</summary>
    <ul>
        一级封锁协议
        <li>事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；</li>
        <li> 一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。</li>
        <li>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。</li>
    </ul>
    <ul>
        二级封锁协议
        <li>在一级的基础上，事务在读取数据之前必须先加S锁，<b>读完后释放S锁。</b>可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；</li>
        <li>二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</li>
    </ul>
    <ul>三级封锁协议
        <li>在二级的基础上，事务在读取数据之前必须先加S锁，<b>直到事务结束才能释放</b>。</li>
    <li>可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）</li>
    <li>上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。</li>
    </ul>
</details>




### 5. 什么是两段锁协议？

<https://www.cnblogs.com/mysql-hang/articles/11027685.html>

<details>
<summary>展开查看</summary>
    <li>事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。</li>
    <li>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。</li>
</details>
> 传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：Two-Phase Locking。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。

![img](https://images2015.cnblogs.com/blog/569491/201605/569491-20160531125643852-1513515378.jpg)

从上图可以看出，2PL就是将加锁/解锁分为两个完全不相交的阶段。加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。



### 6. 什么是死锁？

<details>
<summary>展开查看</summary>
    <li>是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程。</li>
    <li>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</li>
    <li>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</li>
</details>



### 7. 死锁怎么解决?

<details>
<summary>展开查看</summary>
    <ol>
        解决方法：
        <li>查出的线程杀死 kill SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</li>
        <li>设置锁的超时时间:Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</li>
        <li>指定获取锁的顺序</li>
    </ol>
</details>


### 8. mysql共享锁与排他锁

<https://blog.csdn.net/localhost01/article/details/78720727?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task>

> 共享锁与排他锁是行级锁

* 共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是**只能读不能修改**。

* 排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如**一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁**，包括共享锁和排他锁，但是**获取排他锁的事务是可以对数据就行读取和修改**。

* mysql InnoDB引擎默认的修改数据语句，**update,delete,insert都会自动给涉及到的数据加上排他锁**，select语句默认不会加任何锁类型，如果**加排他锁可以使用select ...for update语句**，**加共享锁可以使用select ... lock in share mode语句**。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。



### 9. 知道mysql中的锁吗，说一下表锁，行锁，如何上锁(for update)，举个例子在什么时候事务会进入阻塞状态

<details>
<summary>展开查看</summary>
    <li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
    <li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
</details>


### 10. 行锁的三种算法，以及解决的问题

<https://www.pianshen.com/article/626135269/>

> InnoDB这种行锁实现特点意味着，只有通过索引条件检索条件数据，InnoDB才使用行锁，否则InnoDB将使用表锁。

<details>
<summary>展开查看</summary>
    <ul>行锁的三种算法:
    </ul>
    <li>Record锁：单个行记录上的范围</li>
    <li>gap锁：间隙锁，锁定一个范围，但不包含记录本身</li>
    <li>next-key锁：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身</li>
</details>

<details>
<summary>记录锁 Record Locks</summary>
    <li>Record Lock是对索引项加锁。记录锁有两种模式，S模式和X模式。</li>
    <li>记录锁始终只锁定索引。</li>
    <li>即使表没有建立索引，InnoDB也会创建一个隐藏的聚簇索引(隐藏的递增主键索引)，并使用此索引进行记录锁定。</li>
</details>


<details>
<summary>间隙锁 Gap Locks</summary>
    <li>间隙锁作用在索引记录之间的间隔，又或者作用在第一个索引之前，最后一个索引之后的间隙。不包括索引本身。</li>
    <li>例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;这条语句阻止其他事务插入10和20之间的数字，无论这个数字是否存在。
间隙可以跨越0个，单个或多个索引值。</li>
    <li>InnoDB中的间隙锁的唯一目的是防止其他事务插入间隙。</li>
    <li>如果事务隔离级别改为RC，则间隙锁会被禁用。</li>
</details>
<details>
<summary>Next-key锁</summary>
    <li>Next-key锁实际上是Record锁和gap锁的组合。</li>
    <li>Next-key锁是在下一个索引记录本身和索引之前的gap加上S锁或是X锁(如果是读就加上S锁（共享锁），如果是写就加X锁（排他锁）)。</li>
    <li>InnoDB使用next-key锁对索引进行扫描和搜索，这样就读取不到幻象行，避免了幻读的发生。</li>
    <li>当查询的索引是唯一索引时，Next-key lock会进行优化，降级为Record Lock，此时Next-key lock仅仅作用在索引本身，而不会作用于gap和下一个索引上。</li>
    <li>例如一个索引有10,11,13,20这4个值，那么该索引可能被Next-Key Locking的范围为：
(- &，10]
(10,11]
(13,20]
(20,+ &)</li>
</details>

* **InnoDB这种行锁的实现特点意味着，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟锁表一样。**
* 采用Next-Key Lock的锁定技术称为Next-Key Locking。这种设计的**目的是为了解决幻读**（Phantom Problem）。利用这种锁定技术，锁定的不是单个值，而是一个范围。



### 11. 实现一个读写锁

<https://blog.csdn.net/u014316026/article/details/78726459>

* 读锁（共享锁）是读取操作创建的锁。**其他用户可以并发读取数据，但任何事务都不能对数据进行修改**（获取数据上的排他锁），直到已释放所有共享锁。
  如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。
* 写锁（排他锁）如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务**既能读数据，又能修改数据**。
* 事务可以通过以下语句给sql加共享锁和排他锁：
  * 共享锁：select …… lock in share mode;
  * 排他锁：select …… for update;

共享锁：

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20171205225431141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDMxNjAyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

排他锁：

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20171205225402159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDMxNjAyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)







## 四、索引

### 1. 什么是索引？

<details>
<summary>展开查看</summary>
    <li>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</li>
    <li>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</li>
</details>


### 2.  索引的作用？

<details>
<summary>展开查看</summary>
    <li>协助快速查询、更新数据库表中数据。</li>
    <ul>为表设置索引要付出代价的：
        <li>一是增加了数据库的存储空间</li>
        <li>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</li>
    </ul>
</details>





### 3. 索引的优点缺点是什么？

<details>
<summary>优点</summary>
    <ol>创建索引可以大大<b>提高系统的性能</b>（优点）：
        <li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
        <li>可以大大<b>加快数据的检索速度</b>，这也是创建索引的最主要的原因。</li>
        <li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
        <li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
        <li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
    </ol>
</details>
<details>
<summary>缺点</summary>
    <ol>增加索引也有许多不利的方面(缺点)：
        <li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
        <li><b>索引需要占物理空间</b>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
        <li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
    </ol>
</details>




### 4. 使用B树和B+树的比较

<details>
<summary>展开查看</summary>
    <ul>InnoDB的索引使用的是B+树实现，B+树对比B树的好处：
    	<li>IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；</li>
        <li>范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；</li>
        <li>查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多</li>
    </ul>
</details>


### 5. 使用B树索引和哈希索引的比较

[哈希索引](<https://www.cnblogs.com/igoodful/p/9361500.html>)

<details>
<summary>展开查看</summary>
    <p>
        哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；
    </p>
    <p>
        B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。
    </p>
    <p>
        B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;
    </p>
</details>



### 6. 为什么不使用Hash索引而使用B+树索引？

<details>
<summary>展开查看</summary>
    <li>Hash索引仅仅能满足"=","IN"和""查询，<b>不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</b></li>
    <li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li>
    <li><b>Hash索引不能利用部分索引键查询</b>，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li>
    <li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li>
    <li>Hash索引遇到大量Hash值相等（Hash冲突）的情况后性能并不一定就会比B+树索引高。</li>
    <li><b>哈希索引也<b>不支持多列联合索引的最左匹配规则</b></b></li>
    <li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</li>
</details>




### 7. B树和B+树的区别

<details>
<summary>展开查看</summary>
    <li>1. B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，<b>叶子结点不包含任何关键字信息。</b></li>
    <li>2. B+树，<b>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针</b>，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</li>
</details>


引用：<https://www.jianshu.com/p/cf7dba86c391>

![B树](https://upload-images.jianshu.io/upload_images/1696815-5f9910d07a170002.png?imageMogr2/auto-orient/strip|imageView2/2/w/977/format/webp)



![B+树](https://upload-images.jianshu.io/upload_images/1696815-127a9b91a804a075.png?imageMogr2/auto-orient/strip|imageView2/2/w/689/format/webp)



### 8. 为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？

<details>
<summary>展开查看</summary>
    <ul>1. B+的磁盘读写代价更低
        <li>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。</li>
        <li>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。</li>
        <li>一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li>
    </ul>
    <ul>2. B+tree的查询效率更加稳定
        <li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。</li>
        <li>所以<b>任何关键字的查找必须走一条从根结点到叶子结点的路。</b></li>
        <li>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
    </ul>
</details>



### 9. 聚集索引和非聚集索引区别?

<https://blog.csdn.net/jiadajing267/article/details/54581262>

<details>
<summary>聚合索引(clustered index):</summary>
    <li>简单说：就是将数据存储与索引放到了一块，找到索引也就找到了数据</li>
    <li><b>聚集索引表记录的排列顺序和索引的排列顺序一致</b>，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。</li>
    <li>聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。</li>
    <li>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</li>
</details>

<details>
<summary>非聚合索引(nonclustered index):</summary>
    <li>非聚簇索引在查询时通过索引得到主键的值,然后再拿主键的值去查询聚簇索引得到最终的数据行</li>
    <li>非聚集索引指定了表中记录的逻辑顺序，但是记录的<b>物理和索引不一定一致</b>，两种索引都采用B+树结构，<b>非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式</b>。</li>
    <li>非聚集索引层次多，不会造成数据重排。</li>
    <li>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</li>
    <li>根本区别：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</li>
</details>



何时使用聚簇索引与非聚簇索引

| 动作               | 使用聚簇索引 | 使用非聚簇索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | 应           | 应             |
| 返回某范围内的数据 | 应           | 不应           |
| 一个或极少不同值   | 不应         | 不应           |
| 小数目的不同值     | 应           | 不应           |
| 大数目的不同值     | 不应         | 应             |
| 频繁更新的列       | 不应         | 应             |
| 外键列             | 应           | 应             |
| 主键列             | 应           | 应             |
| 频繁修改索引列     | 不应         | 应             |





### 10. 哪些情况下索引会失效？

<https://blog.csdn.net/u010793461/article/details/79851372>

<details>
<summary>展开查看</summary>
    <li>以“%(表示任意0个或多个字符)”开头的LIKE语句；</li>
    <li>OR语句前后没有同时使用索引；</li>
    <li>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</li>
    <li>对于多列索引，必须满足 最左匹配原则/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；</li>
    <li>如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）</li>
</details>

* 如果条件中有or，即使其中有条件带索引也不会使用(**这也是为什么尽量少用or的原因**)

  **注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引**

  ![](https://s1.ax1x.com/2020/03/31/Gl9ZAf.png)

* like查询是以%开头

  ![](https://s1.ax1x.com/2020/03/31/GlCC5T.png)

* 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

  ![](https://s1.ax1x.com/2020/03/31/GlFeqs.png)

* 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）

* 最佳左前缀法则，带头大哥不能死，中间兄弟不能少。


​    


### 11. 在哪些地方适合创建索引？

> 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。

<details>
<summary>展开查看</summary>
    <li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
    <li>某列经常作为最大最小值；</li>
    <li>经常被查询的字段；可以加快搜索的速度；</li>
    <li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
    <li>经常出现在排序的列上，ORDER BY/GROUP BY/DISDINCT后面的字段</li>
    <li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</details>



### 12. 在哪些地方不适合创建索引？

<details>
<summary>展开查看</summary>
    <li>对于那些在查询中很少使用或者参考的列不应该创建索引。</li>
    <li>对于那些只有很少数据值的列也不应该增加索引。（比如性别）</li>
    <li>对于那些定义为text, image和bit数据类型的列不应该增加索引。（因为这些列的数据量要么相当大，要么取值很少。）</li>
    <li>当修改性能远远大于检索性能时，不应该创建索引。（修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。）</li>
</details>





### 13. 创建索引时需要注意什么？

<details>
<summary>展开查看</summary>
    <li>只应建立在<b>小字段</b>上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；</li>
    <li>建立索引的字段应该<b>非空</b>，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；</li>
    <li>选择<b>数据密度大</b>（唯一值占总数的百分比很大）的字段作索引</li>
</details>



### 14. 索引的分类？

- 普通索引：仅加速查询

  ```mysql
  CREATE INDEX indexName ON mytable(username(length));
  ```

- 唯一索引 UNIQUE：**索引列的值必须唯一**，但**允许有空值**；

  ```mysql
  CREATE UNIQUE INDEX indexName ON mytable(username(length))
  ```

- **主键索引** PRIMARY KEY：必须唯一，**不允许空值**（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；**主键索引只能有一个，唯一索引可有多个**

- 单列索引和多列索引/复合索引（Composite）：索引的列数；

- 覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；

- 聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；

- 分区索引（？）

- 虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用





### 15. 最左前缀原则

[Mysql最左匹配原则](<https://blog.csdn.net/sinat_41917109/article/details/88944290?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task>)

![img](https://img-blog.csdnimg.cn/20190401113210176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxOTE3MTA5,size_16,color_FFFFFF,t_70)

* 如果创建了一个（a, b）的联合索引，那么它的索引树如上图
* 可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。
* 在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。

<details>
<summary>最左前缀原则</summary>
    <li>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。</li>
    <li>上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</li>
</details>


### 16. 主键索引工作的大体流程。

* 主键索引就是一个聚集索引。一个表只能有一个聚集索引。主键索引在MySQL中使用了B+数，在进行主键搜索的过程中，会直接搜索这棵B+树，找到了返回这行的数据即可。搜索的次数为树的层次深度。



#### 以下为扩展主键索引和非主键索引的区别：

假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。

这个表的建表语句是：

```mysql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下

![](https://s1.ax1x.com/2020/03/31/Glkw0s.png)

* 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。
* 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）或普通索引。
* 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）或普通索引。
* 根据上面的索引结构说明，我们来讨论一个问题：**基于主键索引和普通索引的查询有什么区别？**
  * 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
  * 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为**回表**。
* 也就是说，基于非主键索引的查询需要多扫描一棵索引树。这也是为什么说我们要尽量使用主键查询了。



### 17. mysql联合索引

[mysql联合索引的使用规则](<https://blog.csdn.net/wdjxxl/article/details/79790421>)

> 从一道有趣的题目开始分析：
>
> 假设某个表有一个联合索引（c1,c2,c3,c4）以下选项哪些字段使用了该索引：
> A where c1=x and c2=x and c4>x and c3=x
> B where c1=x and c2=x and c4=x order by c3
> C where c1=x and c4= x group by c3,c2
> D where c1=? and c5=? order by c2,c3
> E where c1=? and c2=? and c5=? order by c2,c3

* 首先创建表：

```mysql
CREATE TABLE t(
c1 CHAR(1) not null,
c2 CHAR(1) not null,
c3 CHAR(1) not null,
c4 CHAR(1) not null,
c5 CHAR(1) not null
)ENGINE myisam CHARSET UTF8;
```

有c1到c5 5个字段，特别说明一下 字段类型都是定长char（1）类型，并且非空，字符集是utf8（与计算索引使用字节数有关）

* 创建索引：

```mysql
alter table t add index c1234(c1,c2,c3,c4);
```

* 插入2条数据：

```mysql
insert into t VALUES('1','1','1','1','1'),('2','2','2','2','2')
```

* 使用MySql Explain开始分析题目结果：

#### A选项：

```mysql
explain select * from t where c1="1" and c2="1" and c4>"0" and c3="1";
```

![](https://s1.ax1x.com/2020/03/31/GlVn6U.png)

结果可以看出，c1,c2,c3,c4均使用到了该索引，而我们对A结果稍作更改：

将c2条件去掉后：

![](https://s1.ax1x.com/2020/03/31/GlZTVH.png)

* 根据索引最左原则，c2字段没有使用索引，c2之后的字段都不能使用索引。下面2图我们对比下索引最左原则：

![](https://s1.ax1x.com/2020/03/31/GleLTJ.png)

* 上图结果显示直接使用c3是全表查询，无法使用该索引的，所以c3字段使用索引的前提是c1，c2两字段均使用了索引。即是索引的最左原则（左前缀原则）。

#### B选项：

![](C:\Users\76839\AppData\Roaming\Typora\typora-user-images\1585665843439.png)

* key_len长度说明c1，c2字段用到了该索引，Extra显示并没有使用临时表进行排序，说明排序是使用了索引的，但并没有计算在key_len值中，也没有起到连接c4的作用，说明索引到c3这里是断掉的。
* 排序其实是利用联合索引直接完成了的，即：使用了c1234联合索引，就已经使得c1下c2，c2下c3，c3下c4是有序的了，所以实际是排序利用了索引，c3字段并没有使用该索引。



#### C选项：

![](https://s1.ax1x.com/2020/03/31/GlmwBF.png)

* 使用group by 一般先生成临时文件，再进行排序，但是字段顺序为c2，c3时，并没有用临时表进行排序，
* 而是利用索引排序好的；当group by字段为c3，c2时，由于与索引字段顺序不一致，所以分组和排序并没有利用到索引。
* 由key_len长度确定，只有c1一个字段使用了索引。



#### D选项：

![](https://s1.ax1x.com/2020/03/31/Glmgc6.png)

* order by 和group by 类似，字段顺序与索引一致时，会使用索引排序；字段顺序与索引不一致时，不使用索引。
* 由key_len长度确定，只有c1一个字段使用了索引。



#### E选项：

![](https://s1.ax1x.com/2020/03/31/GlnS4s.png)

* 其实选项E的结果分析在上述ABCD的结果中都分析过了，这里只有c1，c2字段使用了该索引。



综上所述问题答案：

A:四个字段均使用了该索引

B:c1，c2字段使用了该索引

C:c1字段使用该索引

D:c1字段使用该索引

E:c1，c2字段使用了该索引



#### 总结：

* 索引的最左原则（左前缀原则），如（c1,c2,c3,c4....cN）的联合索引，where 条件按照索引建立的字段顺序来使用（不代表and条件必须按照顺序来写），如果中间某列没有条件，或使用like会导致后面的列不能使用索引。
* 索引也能用于分组和排序，分组要先排序，在计算平均值等等。所以在分组和排序中，如果字段顺序可以按照索引的字段顺序，即可利用索引的有序特性。





### 18. 非聚簇索引的查询都要回表吗？

<details>
<summary>展开查看</summary>
    <li>覆盖查询不会进行回表.</li>
    <li>覆盖索引是指,在表中有一个联合索引,若查询时,查询时select的字段为该索引的一个项,且where的也是该索引的一个项,此时就可以通过索引一次性拿到查询结果.</li>
    <li>例如 Student表中有字段number和name,且这两个字段组成联合索引key(number,name),则使用如下查询将使用覆盖索引查询:</li>
    <code>select name from Student where number=1</code>
</details>



### 19. where 中 or 和 and 对于索引的使用有什么区别

<details>
<summary>展开查看</summary>
    <li>在mysql的where条件里, and 优先于 or</li>
    <li>在where中使用and，索引会按照最左原则进行索引</li>
    <li>在where中使用or，只有全部设置索引的时候，才会使用索引，否则将不会使用索引。</li>
    <li>数据量太少，制定执行计划时发现全表扫描比索引查找更快。也不会使用索引</li>
</details>



### 20. MySQL BOOL 类型是否需要建索引

<details>
<summary>展开查看</summary>
    <li>通常不需要, 而且不建议</li>
    <li>1/0 值分布均匀的话，不需要建立索引。如果建立了，并不会使查询更快，反而写入更慢。</li>
    <li>1/0 中的某个值只存在少量的时候。索引有效果。</li>
    <li>从 MySQL 的索引机制来分析，MySQL 使用的是 B-Tree 索引。对于候选值较少的情况， 效果不佳。</li>
    <li>而且数据量很小的情况下，根本不需要索引。</li>
</details>



### 21. MySQL索引结构，主键索引和其他索引结构有什么不同，主键索引查找数据和其他索引查找数据的过程

<details>
<summary>展开查看</summary>
    <li>MySQL索引结构通常是B树，一部分还有Hash索引</li>
    <li>主键索引：一张表中最多有一个主键索引，而且该字段值不能为NULL，不能重复。</li>
    <li>唯一索引：一张表中可以有多个唯一索引，而且字段可以为NULL，但是不能有重复值。</li>
    <li>普通索引：一张表中可以有多个普通索引，而且值可以为NULL，并且值可以重复。</li>
    <Li>全文索引：全文索引就是将该字段的信息加以拆分和组合，形成一份清单，和sphinx全文索引一样。</Li>
    <li>复合索引：一个索引如果建立在多个字段上，那该索引就称为复合索引。</li>
    <li>主键索引的叶子节点存的是整行数据，在搜索B+树时找到了数据即可返回所需的数据</li>
    <li>其他索引都是非聚簇索引，叶子节点上存的是主键，要进行回表，回到表中按主键找到对应行的数据</li>
</details>


### 22. B+树中叶子节点间的指针有什么用

<details>
<summary>展开查看</summary>
    <li>B+树只有叶结点存储数据。叶结点连起来正好是所有数据的有序序列，可以用来做<b>全表顺序扫描或者范围查询</b>。</li>
    <li>B数的数据存储在各层结点上，叶结点只有部分数据，连起来也没有任何用处。</li>
</details>









## 五、数据库优化

> 实践中，MySQL的优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面，如下图所示：

![](https://s1.ax1x.com/2020/04/01/G1Cyu9.png)



#### (1)怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）

* MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。

* long_query_time的默认值为10，意思是运行10s以上的语句。慢查询日志的相关参数如下所示：

  ![](https://s1.ax1x.com/2020/04/01/G1VoJ1.png)

* 通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。

#### (2)通过explain查询和分析SQL的执行计划

* 使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。
* 通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。
* 当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。




### 1. 如何优化数据库？

<details>
<summary>SQL语句的优化</summary>
    <li>优化insert语句：一次插入多值；</li>
    <li>应尽量避免在 where 子句中使用 != 、< 、>操作符，否则将引擎放弃使用索引而进行全表扫描；</li>
    <li>只返回必要的列：最好不要使用 SELECT * 语句；</li>
    <li>只返回必要的行：使用 LIMIT 语句来限制返回的数据；</li>
    <li>应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；</li>
    <li>优化嵌套查询：子查询可以被更有效率的连接(Join)替代；</li>
    <Li>很多时候用 exists 代替 in 是一个好的选择。</Li>
</details>

<details>
<summary>索引优化</summary>
    <li><b>注意会引起索引失效的情况，以及在适合的地方建立索引</b></li>
    <li>建议在经常作查询选择的字段、经常作表连接的字段以及经常出现在order by、group by、distinct 后面的字段中建立索引。但必须注意以下几种可能会引起索引失效的情形：</li>
    <li>OR语句前后没有同时使用索引；</li>
    <li>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</li>
    <li>以“%(表示任意0个或多个字符)”开头的LIKE语句，模糊匹配</li>
    <Li>对于多列索引，必须满足最左匹配原则(eg,多列索引col1、col2和col3，则 索引生效的情形包括col1或col1，col2或col1，col2，col3)。</Li>
</details>
<details>
<summary>数据库表结构的优化</summary>
    <ul>
        <b>选择合适数据类型</b>
        <li>使用较小的数据类型解决问题；</li>
        <li>使用简单的数据类型(mysql处理int要比varchar容易)；</li>
        <li>尽可能的使用not null 定义字段；</li>
        <li>尽量避免使用text类型，非用不可时最好考虑分表；</li>
    </ul>
    <ul><b>表的范式的优化</b>
        <li>一般情况下，表的设计应该遵循三大范式。</li>
    </ul>
    <ul><b>表的垂直拆分</b>。把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段：
        <li>把不常用的字段单独放在同一个表中；</li>
        <li>把大字段独立放入一个表中；</li>
        <li>把经常使用的字段放在一起；</li>
    </ul>
    <p>这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单。</P>
<ul>
    <b>表的水平拆分</b>
    <li>表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：</li>
    <li>对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；</li>
    <li>针对不同的hashID将数据存入不同的表中；</li>
    <li>表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处：</li>
    <li>表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；</li>
    <li>表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</li>
    <li>需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)。</li>
</ul>
</details>

<details>
<summary>系统配置的优化</summary>
    <li>操作系统：增加TCP支持的队列数；</li>
    <li>MySQL配置文件优化：缓存池大小和个数设置</li>
</details>

<details>
<summary>硬件的优化</summary>
    <li>磁盘性能：固态硬盘；</li>
    <li>CPU：多核且高频；</li>
    <li>内存：增大内存</li>
</details>





### 2. 使用explain优化sql和索引?

> 对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化

```
EXPLAIN SELECT * FROM book WHERE `bookid`=1 OR `bookname`='平凡的世界' or year_publication = 1986;
```

| id   | select_type | table | partitions | type | possible_keys                     | key  | key_len | ref  | rows | filtered | Extra       |
| ---- | ----------- | ----- | ---------- | ---- | --------------------------------- | ---- | ------- | ---- | ---- | -------- | ----------- |
| 1    | SIMPLE      | book  | NULL       | ALL  | PRIMARY,year_publication,bookname | NULL | NULL    | NULL | 60   | 12.98    | Using where |

* table：显示这一行的数据是关于哪张表的
* type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为`const`、`eq_ref`、`ref`、`range`、`index`和`ALL`

  * all:full table scan ;MySQL将遍历全表以找到匹配的行；

  * index: index scan; index 和 all的区别在于index类型只遍历索引；

  * range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；

  * ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；

  * eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；

  * const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。
* possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句
* key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引
* key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好
* ref：显示索引的哪一列被使用了，如果可能的话，是一个常数
* rows：MySQL认为必须检查的用来返回请求数据的行数
* Extra：关于MySQL如何解析查询的额外信息。坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。



### 3. 如果表的数据量非常大怎么优化

<https://blog.csdn.net/qq_41615095/article/details/86009872>

<details>
<summary>展开查看</summary>
    <li>优化sql语句（这个是最简便的,也是在开发是一定要注意的）</li>
    <li>索引（加正确的索引）</li>
    <li>引擎（特点：MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表，我的表既查询多，插入也不少，所以不适用）</li>
    <li>提升硬件（这个就不多说了，烧钱就能解决）</li>
    <li><b><font color=red> 拆表:水平拆表和垂直拆表</font></b></li>
</details>


<details>
<summary>水平拆分</summary>
    <ul>
        优点
        <li>不存在单库大数据和高并发的性能瓶颈</li>
        <li>应用端改造较少</li>
        <li>提高了系统的稳定性和负载能力</li>
    </ul>
    <ul>
        缺点
        <li>分片事务一致性难以解决</li>
        <li>跨节点Join性能差，逻辑复杂</li>
        <li>数据多次扩展难度跟维护量极大</li>
    </ul>
</details>

<details>
<summary>垂直拆分</summary>
    <ul>
        优点
        <li>可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)</li>
        <li>可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起
数据维护简单</li>
    </ul>
    <ul>
        缺点
        <li>主键出现冗余，需要管理冗余列</li>
        <li>会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力</li>
        <li>依然存在单表数据量过大的问题（需要水平拆分）</li>
        <li>事务处理复杂</li>
        <li>（主要为了解决有的字段数据量较大又不需查询）</li>
    </ul>
</details>

[MySQL处理达到百万级数据时，如何优化？](<https://blog.csdn.net/wxb880114/article/details/81019654?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task>)

所想方案：将表水平分割成历史表，将数据按今年之前分割存储另一张表（冷数据，一般不会详细查询），另建一张结果表用以存储冷数据按年或月数据的统计，若涉及统计直接从结果表中取出，用以提高效率。





## 六、存储引擎

### 1. MySQL的两种存储引擎 **InnoDB** 和 MyISAM 的区别？

<details>
<summary>展开查看</summary>
    <li>InnoDB<b>支持事务</b>，可以进行Commit和Rollback；</li>
    <li>MyISAM 只支持表级锁，而 InnoDB 还<b>支持行级锁</b>，提高了并发操作的性能；</li>
    <li>InnoDB<b>支持外键</b>；</li>
    <li>MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢；</li>
    <li>MyISAM 支持<b>压缩</b>表和空间数据索引，InnoDB需要更多的内存和存储；</li>
    <li>InnoDB支持在线<b>热备份</b></li>
    <li>从MySQL5.5.5以后，InnoDB是默认引擎。</li>
</details>
<details>
<summary>应用场景</summary>
    <li>MyISAM 管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；</li>
    <li>InnoDB 支持事务，并发情况下有很好的性能，基本可以替代MyISAM</li>
</details>

<details>
<summary>热备份和冷备份</summary>
    <li>热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，<b>备份时数据库仍可使用，可恢复至任一时间点</b>。但是不能出错</li>
    <li>冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单</li>
</details>

<details>
<summary>核心区别</summary>
    <li>MyISAM是非事务安全型的，而InnoDB是事务安全型的。</li>
    <li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li>
    <li>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li>
    <li>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li>
    <li>MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li>
    <li>InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。	</li>
    <li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li>
    <li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。	</li>
</details>


1）事务：MyISAM不支持，InnoDB支持
2）锁级别： MyISAM 表级锁，InnoDB 行级锁
MySQL表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。
InnoDB行锁是通过给索引项加锁来实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁！
3）MyISAM存储表的总行数；InnoDB不存储总行数；
4）MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据
5）适用场景：
MyISAM适合： 插入不频繁，查询非常频繁， 没有事务。
InnoDB适合： 要求事务； 表更新和查询都相当的频繁



### 2. 什么是MVCC（多版本并发控制）？

<https://blog.csdn.net/chosen0ne/article/details/18093187>

<details>
<summary>展开查看</summary>
    <li>MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</li>
    <li>select：事务每次只能读到创建版本号小于等于此次系统版本号的记录，同时行的删除版本号不存在或者大于当前事务的版本号。</li>
    <li>update：插入一条新记录，并把当前系统版本号作为行记录的版本号，同时保存当前系统版本号到原有的行作为删除版本号。</li>
    <li>delete：把当前系统版本号作为行记录的删除版本号</li>
    <li>insert：把当前系统版本号作为行记录的版本号</li>
    <li>写操作（insert、delete和update）执行时，需要将系统版本号递增。</li>
    <li>由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</li>
    <li>MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能</li>
</details>






### 3. InnoDB 怎么防止幻读

> 幻读问题是指一个事务的两次不同时间的相同查询返回了不同的的结果集。

<https://blog.csdn.net/qq_33330687/article/details/89004462>

<details>
<summary>展开查看</summary>
    <ul>
        MySQL在默认RR的隔离级别下实现避免幻读
    </ul>
    <li>在快照读读情况下，mysql通过mvcc来避免幻读。</li>
    <li>在当前读读情况下，mysql通过next-key来避免幻读</li>
</details>

<details>
<summary>什么是next-key锁</summary>
    <li>可以简单的理解为record locks+gap locks:</li>
</details>

<details>
    <summary>快照读</summary>
    <li>简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</li>
    <li>select * from table where ?;</li>
</details>

<details>
    <summary>当前读</summary>
    <li>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</li>
    <li>select * from table where ? lock in share mode;</li>
    <li>select * from table where ? for update;</li>
    <li>insert into table values (…);</li>
    <li>update table set ? where ?;</li>
    <li>delete from table where ?;</li>
</details>



### 3. InnoDB常见的锁

<details>
<summary>展开查看</summary>
    <ul>InnoDB常见的锁:
    </ul>
    <li>Record锁</li>
    <li>gap锁</li>
    <li>next-key锁</li>
</details>

<details>
<summary>记录锁 Record Locks</summary>
    <li>Record Lock是对索引记录的锁定。记录锁有两种模式，S模式和X模式。</li>
    <li>记录锁始终只锁定索引。</li>
    <li>即使表没有建立索引，InnoDB也会创建一个隐藏的聚簇索引(隐藏的递增主键索引)，并使用此索引进行记录锁定。</li>
</details>

<details>
<summary>间隙锁 Gap Locks</summary>
    <li>间隙锁作用在索引记录之间的间隔，又或者作用在第一个索引之前，最后一个索引之后的间隙。不包括索引本身。</li>
    <li>例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;这条语句阻止其他事务插入10和20之间的数字，无论这个数字是否存在。
间隙可以跨越0个，单个或多个索引值。</li>
    <li>InnoDB中的间隙锁的唯一目的是防止其他事务插入间隙。</li>
    <li>如果事务隔离级别改为RC，则间隙锁会被禁用。</li>
</details>

<details>
<summary>Next-key锁</summary>
    <li>Next-key锁实际上是Record锁和gap锁的组合。</li>
    <li>Next-key锁是在下一个索引记录本身和索引之前的gap加上S锁或是X锁(如果是读就加上S锁（共享锁），如果是写就加X锁（排他锁）)。</li>
    <li>InnoDB使用next-key锁对索引进行扫描和搜索，这样就读取不到幻象行，避免了幻读的发生。</li>
    <li>当查询的索引是唯一索引时，Next-key lock会进行优化，降级为Record Lock，此时Next-key lock仅仅作用在索引本身，而不会作用于gap和下一个索引上。</li>
</details>


### 4. 为什么MyISAM不支持行锁，而InnoDB支持，还有他俩的区别

[Myisam与Innodb索引的区别](<https://blog.csdn.net/qq_25551295/article/details/48901317>)

* myisam的索引存储图如下，可以看出，无论是id还是cat_id，下面都存储有执行物理地址的值。通过主键索引或者次索引来查询数据的时候，都是**先查找到物理位置，然后再到物理位置上去寻找数据**。

![img](https://img-blog.csdn.net/20151004223450594)

* innodb的索引存储图如下，我们会发现，主**键索引下面直接存储有数据，而次索引下，存储的是主键的id**。通过主键查找数据的时候，就会很快查找到数据，但是通过次索引查找数据的时候，需要先查找到对应的主键id，然后才能查找到对应的数据。

![img](https://img-blog.csdn.net/20151004223815368)

* innodb的主索引文件上 直接存放该行数据,称为聚簇索引,次索引指向对主键的引用
* myisam中, 主索引和次索引,都指向物理行(磁盘位置).



* InnoDB行锁是通过给索引上的索引项加锁来实现的
* **MyIsam索引和数据分离，InnoDB在一起**，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”



**那么答案也出来了，InnoDB之所以可以锁行，是因为Innodb的主索引结构上，既存储了主键值，又直接存储了行数据，可以方便的锁住行数据，而MyIsam索引指向另一片数据文件，没有办法精确锁住数据段**



### 5. Mysql两种引擎相关的问题，你是如何看待大家认为的Innodb要比MyISAM快的，谈谈你的看法

>  自己的想法：MyISAM 它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；

1. 设计目标

   * InnoDB设计目标是处理大容量的数据，
   * 而MyISAM追求的是性能

2. 事务处理

   * InnoDB支持事务和外键，MyISAM不支持。
   * InnoDB支持事务带来了一个好处，发生故障时可以通过事务日志来恢复数据库
   * MyISAM特别要命的一点是崩溃后不能安全恢复，所以对于表比较大的情况不要用。

3. 效率和锁

   * MyISAM是表锁，对数据库进行写操作时会锁住整个表，效率很低
   * 确定要修改数据的范围时，InnoDB是行锁，只锁一行的数据，写操作很快
   * 但也有特例，比如UPDATE student SET age=10 WHERE name LIKE ‘王%’，这种情况不能确定要UPDATE的行位置，InnoDB同样会锁住整个表。

4. 索引

   * MyISAM支持全文索引，InnoDB不支持。
   * COUNT(*)
   * MyISAM保存了表的行数，InnoDB没有。也就是说，执行SELECT COUNT(*) FROM student的操作时，MyISAM可以直接给出结果，而InnoDB要先扫描全表。不过对于加了where条件的查询操作，效果是一样的。



## 七、其他

### 1. 什么是数据库的主从复制？

<details>
<summary>展开查看</summary>
    <li>主从复制（也称 AB 复制）允许将来自一个MySQL数据库服务器（主服务器）的数据复制到一个或多个MySQL数据库服务器（从服务器）。
    <li>默认采用异步模式。</li>
</details>



### 2. 主从复制的几种方式

<details>
<summary>展开查看</summary>
    <li>同步复制:所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</li>
    <li>异步复制:如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</li>
    <li>半同步复制:master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</li>
</details>



### 3. 主从复制的实现原理

<details>
<summary>展开查看</summary>
    <li>主服务器 binary log dump 线程：将主服务器中的数据更改（增删改）日志写入 Binary log 中；</li>
    <li>从服务器 I/O 线程：负责从主服务器读取binary log，并写入本地的 Relay（中继） log；</li>
    <li>从服务器 SQL 线程：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性</li>
</details>




### 4. 为什么要主从复制？

<details>
<summary>展开查看</summary>
    <li>读写分离：主服务器负责写，从服务器负责读</li>
    <ul>
        读写分离好处：
        <li>缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；</li>
        <li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
        <li>增加冗余，提高可用性</li>
    </ul>
    <li>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换</li>
    <li>降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能</li>
</details>





### 5. 数据库主从复制分析的 7 个问题?

#### 问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？

<details>
<summary>展开查看</summary>
    <li>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。</li>
    <li>因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。</li>
    <li>实际上，这里已经揭示了读写分离的概念。</li>
</details>



#### 问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？

<details>
<summary>展开查看</summary>
    <li>实现数据备份:类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</li>
    <li>异地容灾:比如master在北京，地震挂了，那么在上海的slave还可以继续。主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。
</li>
    <li>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</li>
</details>



#### 问题3：主从复制中有master,slave1,slave2,...等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?

<details>
<summary>展开查看</summary>
    <li>我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，</li>
    <li>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。
</li>
    <li>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？</li>
    <li>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。</li>
    <li>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</li>
    <li>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</li>
</details>





#### 问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？

<details>
<summary>展开查看</summary>
    <li>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</li>
</details>



#### 问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,...它们怎么办？

<details>
<summary>展开查看</summary>
    <li>显然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。</li>
    <li>master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主，同时slave-1不再负责select。 </li>
    <li>slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</li>
</details>



#### 问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。

<details>
<summary>展开查看</summary>
    <li>应该找一个共享式的缓存，比如memcache来解决。</li>
    <li>将slave-2,slave-3,...这些查询的结果都缓存至mamcache中。</li>
</details>



#### 问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？

<details>
<summary>展开查看</summary>
    <li>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。</li>
    <li>scale out ? 主从复制架构已经满足不了。</li>
    <li>可以分库【垂直拆分】，分表【水平拆分】。</li>
</details>


### 6. mysql 高并发环境解决方案?

> 高并发（High Concurrency）是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问收到大量请
>
> 求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。

**MySQL 高并发环境解决方案：** 分库 分表 分布式 增加二级缓存。。。。。

**需求分析：**互联网单位 每天大量数据读取，写入，并发性高。

**现有解决方式：**水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。

**集群方案：**解决DB宕机带来的单点DB不能访问问题。

**读写分离策略：**极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。







### 7. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?

#### Undo Log:

* Undo Log是**为了实现事务的原子性**，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。
* 事务的原子性(Atomicity)**事务中的所有操作，要么全部完成，要么不做任何操作**，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。
* 原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。
* 如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。
* 之所以能同时保证原子性和持久化，是因为以下**特点：**

  * **更新数据前记录Undo log**。

  * 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。

  * **Undo log必须先于数据持久化到磁盘**。如果在G,H之间系统崩溃，**undo log是完整的， 可以用来回滚事务。**

  * 如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。
* 缺陷：
    * **每个事务提交前将数据和Undo Log写入磁盘**，这样会导致大量的磁盘IO，因此性能很低。
    * 如果能够将数据缓存一段时间，就能减少IO提高性能。
    * 但是这样就会丧失事务的持久性。
    * 因此引入了另外一种机制来实现持久化，即Redo Log。

#### Redo Log:

* 原理和Undo Log相反，Redo Log记录的是新数据的备份。
* 在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。
* 当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。
* 系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

```
引用自：https://blog.csdn.net/mydriverc2/article/details/50629599

事务的简化过程
假设有A、B两个数据，值分别为1,2，现在修改为3、4
1. 事务开始。
2. 记录A=1到undolog。
3. 修改A=3。
4. 记录A=3到redolog。
5. 记录B=2到undolog。
6. 修改B=4。
7. 记录B=4到redolog，将redolog写入磁盘。
8. 事务提交。
```



### 8. MySQL的体系结构

![](https://s1.ax1x.com/2020/03/29/GVQ0Xj.png)

#### 连接器

第⼀步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。

#### 查询缓存 

* 连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第⼆步：查询缓存。 
* 建议不要用查询缓存，查询缓存的失效非常频繁，只要有对⼀个表的更新，这个表上所有的查询缓存都会被清空。 

#### 分析器 

* 如果没有命中查询缓存，就要开始真正执行语句了。 
* 分析器先会做“**词法分析**”。你输入的是由多个字符串和空格组成的⼀条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 

#### 优化器

- 经过了分析器，MySQL就知道你要做什么了。在开始执⾏之前，还要先经过优化器的处理 

- 优化器是在表里面有多个索引的时候，**决定使用哪个索引**；

- 或者在⼀个语句有多表关联（join）的时候，**决定各个表的连接顺序**。比如你执行下面这样的语句，这个语句是执行两个表的join：

  ```
  mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
  ```

- 这两种执行方法的逻辑结果是⼀样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪⼀个方案。

#### 执行器

MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，**开始执行语句**。 





### 9. sql与nosql区别

1、概念：

* SQL（Structured Query Language）数据库，指关系型数据库。主要代表：SQL Server、Oracle、MySQL、PostgreSQL。
* NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB、Redis、CouchDB。



2. NoSQL与SQL的区别：

* SQL数据库：
  * 在使用之前需要定义表的一个模式
  * 在表中存储相关联的数据
  * 支持join多表查询
  * 提供事务
  * 使用一个强声明性语言查询
  * 提供足够的支持，专业技能和工具

 

* NoSQL数据库：
  * 将相关联的数据存储在类似JSON格式，名称-值
  * 可以保存没有指定格式的数据
  * 保证更新一个文档，但不是多个文档
  * 逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作。
  * 使用JSON数据对象查询





### 10. 你用redis做过哪些事？了解redis的持久化吗？

* Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。
* 实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

### 11. 展开讲讲mysql和MongoDB的区别，为什么

什么是MongoDB ?

> MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

MongoDB和MySQL比较

| 数据库       | MongoDB                                              | MySQL                        |
| ------------ | ---------------------------------------------------- | ---------------------------- |
| 数据库模型   | 非关系型                                             | 关系型                       |
| 存储方式     | 以类JSON的文档的格式存储                             | 不同引擎有不同的存储方式     |
| 查询语句     | MongoDB查询方式（类似JavaScript的函数）              | SQL语句                      |
| 数据处理方式 | 基于内存，将热数据存放在物理内存中，从而达到高速读写 | 不同引擎有自己的特点         |
| 成熟度       | 新兴数据库，成熟度较低                               | 成熟度高                     |
| 广泛度       | NoSQL数据库中，比较完善且开源，使用人数在不断增长    | 开源数据库，市场份额不断增长 |
| 事务性       | 仅支持单文档事务操作，弱一致性                       | 支持事务操作                 |
| 占用空间     | 占用空间大                                           | 占用空间小                   |
| join操作     | MongoDB没有join                                      | MySQL支持join                |



### 12. 用过redis吗？有哪些常用数据类型？

<https://blog.csdn.net/Butterfly_resting/article/details/89668661>

一共五种。

(一)String

* 最常规的set/get操作，

* value可以是String也可以是数字。一般做一些**复杂的计数功能的缓存。**

(二)hash
* **这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段**。
* 博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。

(三)list
* 使用List的数据结构，可以**做简单的消息队列的功能**。
* 另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。
* 本人还用一个场景，很合适——取行情信息。
* 就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。

(四)set
* 因为set堆放的是一堆**不重复值的集合**。
* 所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？
* 因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
* 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

(五)sorted set
* sorted set多了一个权重参数score,**集合中的元素能够按score进行排列**。
* 可以做**排行榜应用，取TOP N操作**。





## 八、MySQL语句

### 1. 写查询，mysql查找一个表中重复列值的个数，join查询会写吗

![](https://s1.ax1x.com/2020/04/01/G8DW0f.png)

```mysql
select b, count(*) as count from z group by b having count>1;
```





### 2. 有一张表，数据类型有不同的type，统计有多少种type，写sql

```mysql
select type,count(type) from news
group by type;
```





### 3. 出了一道题，学生，老师，图书，学生借书需要经过老师的同意，设计表实现第三范式，需要几张表，分别是什么？







