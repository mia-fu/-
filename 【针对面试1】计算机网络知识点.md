[TOC]

## 分层的概念

### 1. OSI 有哪几层，会画出来，知道主要几层的各自作用 

<details>
<summary>展开查看</summary>
   	<ol>
        <li>应用层（数据）</li>
        <li>表示层（数据）</li>
        <li>会话层（数据）</li>
        <li>传输层（帧）</li>
        <li>网络层（包）</li>
        <li>数据链路层（帧）</li>
        <li>物理层（比特列）</li>
    </ol>   
</details>

<details>
<summary>应用层作用</summary>
    <p>
        确定进程之间通信的性质以满足用户需要以及提供网络与用户应用
    </p>
</details>

<details>
<summary>会话层作用</summary>
    <p>
        确定进程之间通信的性质以满足用户需要以及提供网络与用户应用
    </p>
</details>

<details>
<summary>传输层作用</summary>
    <p>
        实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等
    </p>
</details>

<details>
<summary>网络层作用</summary>
    <p>
        提供逻辑地址（IP）、选路，数据从源端到目的端的
    </p>
</details>

<details>
<summary>数据链路层作用</summary>
    <p>
        将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正
    </p>
</details>

<details>
<summary>物理层作用</summary>
    <p>
        设备之间比特流的传输，物理接口，电气特性等
    </p>
</details>

### 2. 知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关） 

<details>
<summary>网关</summary>
    <p>
        应用层、传输层（网关在传输层上以实现网络互连，是最复杂的网络互连设
备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是
互连层。网关既可以用于广域网互连，也可以用于局域网互连）
    </p>
</details>

<details>
<summary>路由器</summary>
    <p>
        网络层（路由选择、存储转发），根据IP地址进行寻址
    </p>
</details>

<details>
<summary>交换机</summary>
    <p>
        交换机数据链路层，根据MAC地址进行寻址（识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中）
    </p>
</details>
<details>
<summary>网桥</summary>
    <p>
        数据链路层（将两个 LAN 连起来，根据 MAC 地址来转发帧）
    </p>
</details>

<details>
<summary>集线器（Hub）</summary>
    <p>
        物理层（纯硬件设备，主要用来连接计算机等网络终端）
    </p>
</details>

<details>
<summary>中继器</summary>
    <p>
        物理层（在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离）
    </p>
</details>



## 数据链路层

### 1. ARP是什么？说说工作过程？

<details>
<summary>展开查看</summary>
    <p>
        地址解析协议，即ARP（Address ResoluTIon Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
    </p>
    <p>
        主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；
    </p>
    <p>
        收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。
    </p>
</details>


<details>
<summary>工作过程</summary>
    <ol>
        首先根据主机A上的路由表内容，确定主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。
    </ol>
    <ol>
        如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。
    </ol>
    <ol>
        主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
    </ol>
    <ol>
        当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。
    </ol>
</details>




### 2. ARP 的作用？ 

<details>
<summary>展开查看</summary>
    <p>
        ARP 为 IP 地址到对应的硬件地址（MAC地址）提供动态映射。
    </p>
</details>



### 3. 点对点链路使用 ARP 吗？ 

<details>
<summary>展开查看</summary>
    <p>
        不使用
    </p>
</details>



### 4. ARP 高效运行的关键是什么？ 

<details>
<summary>展开查看</summary>
    <li>
        关键是每个主机上都有一个 ARP 的高速缓存表。 
    </li>
    <li>
        ARP高速缓存中含有最近使用过的IP地址和MAC地址的映射表。
    </li>
</details>





### 5. 为什么需要ARP协议？

<details>
<summary>展开查看</summary>
    <p>
        因为在OSI七层模型中，对数据从上到下进行封装发送出去，然后对数据从下到上解包接收，但是上层（网络层）关心的IP地址，下层关心的是MAC地址，这个时候就需要映射IP和MAC。
    </p>
</details>



### 6. ARP 报文的各个字段以及含义？ 

![1584970200237](https://s1.ax1x.com/2020/03/27/GicDWd.png)

* 帧类型： ARP： 0x0806 （2）
* ARP 首部：
* 硬件类型：硬件地址的类型， 1 表示以太网地址。（2）
* 协议类型：协议地址的类型， 0x0800 表示 IP 地址。 (2)
* 硬件地址长度： 字节为单位 6 （1）
* 协议地址长度： 字节为单位 4 (1)
* 操作类型： 2 个字节。 ARP 请求 1， ARP 回复 2， RARP 请求 3， 
* RARP 应答 4。（2）
* 发送者硬件地址： 6 个字节（6）
* 发送者 IP 地址： 4 个字节（4）
* 目标硬件地址： 6 个字节（6）
* 目标 IP 地址： 4 个字节（4）
* CRC 校验： 4 个字节 （4）
* 总结：arp 总共 28 个字节。
* 记忆方法： 以太网先目地后源， ARP 先发送端后目地端。先硬件后协议 



### 7. ARP 协议有什么弱点？ 

<details>
<summary>展开查看</summary>
    <li>
        缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。 可以通过下次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者 ARP 欺骗。
    </li>
    <li>
        广播: 攻击者可以伪装ARP应答。
    </li>
    <li>
        ARP是无状态的协议。不会检查自己是否发过请求包，也不管（其实也不知道）是否是合法的应答，只要收到目标MAC是自己的ARP reply包或arp广播包（包括ARP request和ARP reply），都会接受并缓存。
    </li>
</details>



### 8. ARP 代理的概念和应用场景 

<details>
<summary>展开查看</summary>
    <li>
        ARP请求是二层广播包，广播包没法过路由器
    </li>
    <li>
        若 ARP 请求是从一个网络的主机发送给另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程叫做 ARP 代理。 ARP 代理路由器响应 ARP 请求的 MAC 地址为路由器的 MAC 地址而非 ARP 请求的主机的 MAC 地址。
    <li>
        ARP 代理的应用环境：当电脑没有网关/路由功能时，并且需要跨网站通信时，则会触发代理ARP。
    </li>
</details>
[图解ARP](https://blog.51cto.com/chenxinjie/1961255)



### 9. 免费ARP协议是什么

<details>
<summary>展开查看</summary>
    <p>
        指主机发送 ARP 查找自己的 IP 地址，即数据链路层 SIP=DIP
    </p>
    <ol>
		作用有两个：
        <li>一个主机使用免费 ARP 确定是否有存在有其他主机设置了相同的 IP 地址</li>
        <li>如果发送免费 ARP 的主机改变了 MAC 地址，可以通过发送免费 ARP 的方式告知其他主机端更新 ARP 表 （告诉其他人我换名了，你们记一下）</li>
    </ol>
</details>

[免费ARP](<https://www.cnblogs.com/gavanwanggw/p/6721384.html>)





### 10. 数据链路层 MTU 的最大值和最小值是多少？ 

<details>
<summary>展开查看</summary>
    <li>
        数据链路层的<b>最小 MTU 为 64 字节</b>。对于 IEEE802.3，两个站点的最远距离不超过 2500m，由 4 个中继器连接而成，其冲突窗口为 51.2us(2 倍电缆传播延迟加上 4 个中继器的双向延迟).对于 10Mbps 的 IEEE802.3 来说，这个时间等于发送 64 字节，即 512 位的时间， 64 字节就是由此而来的。如果一个站点已经传输了 512bit，就认为它已经占用了这个信道。
    </li>
    <li>
        数据链路层的<b>最大 MTU 为 1500 字节</b>，即数据字段的最大长度 
    </li>
</details>


## 网络层 IP

![](https://s1.ax1x.com/2020/03/27/GijVN4.png)

![1584608870120](https://s1.ax1x.com/2020/03/27/GicqmV.png)

### 1. 如何理解 IP 的不可靠和无连接。 

<details>
<summary>不可靠</summary>
    <p>
        指的是不能保证数据报能成功地到达目的地。
    </p>
    <p>
        发生错误时候，丢弃该数据包，发送 ICMP 消息给信源端。可靠性由上层提供。
    </p>
</details>

<details>
<summary>无连接</summary>
    <p>
        IP 不维护关于后续数据报的状态信息。
    </p>
    <p>
        体现在， IP数据可以不按顺序发送和接收。A发送连续的数据报，到达B不一定是连续的，来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。
    </p>
    </p>
</details>


### 2. IP 首部校验和怎么计算的，与 ICMP， IGMP， TCP， UDP 的首部校验和有什么区别与共同点？  

<details>
<summary>展开查看</summary>
    <ol>
        计算过程
        <li>先把校验和字段置0。</li>
        <li>对首部中每个16位比特进行二进制反码求和。</li>
        <li>结果存在检验和字段中。</li>
        <li>收到一份 IP 数据包后，同样对首部中每个 16bit 二进制反码求和。</li>
        <li>最后结果全为 1，表示正确，否则表示错误。</li>
        <li>如果是错误的， IP 就丢弃该数据报，但是不生成差错报文，由上层去处理。</li>
    </ol>
<p>
    共同点：用到的算法都是一样的。
    </p>
    <p>
        区别： IP 计算的时候没有将数据包括在内。
ICMP， IGMP， TCP， UDP 同时覆盖首部和数据检验码
    </p>
</details>

### 3. 主机和路由器本质区别是？ 

<details>
<summary>展开查看</summary>
    <p>
        主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。
    </p>
</details>



### 4. IP 路由选择的过程是怎么样的？ 

<details>
<summary>展开查看</summary>
    <p>
        根据最长匹配原则，找到条目，发送到指定的路由器。如果不能找到，返回一个“主机不可达”或“网络不可达”的错误
    </p>
</details>



### 5. IP 路由选择的特性有什么？ 

<details>
<summary>展开查看</summary>
    <li>IP 路由选择是逐跳进行的。IP 并不知道到达任何目的的完整路径，只提供下一跳地址（MAC地址）。
    </li>
    <li>为一个网络指定一个路由器，而不是为每个主机指定一个路由器。
这样可以缩小路由表规模。 </li>
</details>





### 6. ping是如何工作的？

1. ping过程解析：

- A 电脑（ 192.168.2.135）发起 ping请求， ping 192.168.2.179
- A 电脑广播发起 ARP请求，查询 192.168.2.179的 MAC地址。
- 电脑应答 ARP请求，向A电脑发起单向应答，告诉 A电脑自己的 MAC地址为 90:A4:DE:C2:DF:FE
- 知道了 MAC地址后，开始进行真正的 ping请求，由于 B电脑可以根据A电脑发送的请求知道 **源 MAC地址**，所以就可以根据源 MAC地址进行响应了。

1. 流程图如下：

![img](https://s1.ax1x.com/2020/03/27/GijN8A.png)

- Ping 4次请求和响应结束后，还有一次 B电脑对 A电脑的 ARP请求，这是为什么呢？这里我猜测应该是有 2个原因：
  - 由于 ARP有缓存机制，为了防止 ARP过期，结束后重新更新下 ARP缓存，保证下次请求能去往正确的路径，如果 ARP过期就会导致出现一次错误，从而影响测试准确性。
  - 由于 ping命令的响应时间是根据请求包和响应包的时间戳计算出来的，所以一次 ARP过程也是会消耗时间。这里提前缓存最新的 ARP结果就是节省了下次 ping的 ARP时间。

1. 总结：
   - ping命令是依托于 ICMP协议的， ICMP协议的存在就是为了更高效的转发 IP数据报和提高交付成功的机会。 
   - ping命令除了依托于 ICMP，在局域网下还要借助于 ARP协议， ARP协议能根据 IP地址反查出计算机的 MAC地址。
   - 另外 ARP是有缓存的，为了保证 ARP的准确性，计算机会更新ARP缓存。



 ### 7. IP 地址的分类，如何划分的，及会计算各类地址支持的主机数 

<details>
<summary>展开查看</summary>
    <li>A 类地址：首位为 0， 1.0.0.1~~126.255.255.254；主机号 24 位
    </li>
    <li>B 类地址：首位为 10， 128.0.0.1~~191.255.255.254；主机号 16 位 </li>
    <li>C 类地址：首位为 110， 192.0.0.1~~223.255.255.254；主机号 8 位</li>
    <li>D 类地址（多播地址，也叫做组播地址）：首位为 1110， 224.0.0.1~~239.255.255.254</li>
    <li>E 类地址：此类地址是保留地址，首位为 11110， 240.0.0.1~~254.255.255.254</li>
</details>
![img](https://s1.ax1x.com/2020/03/27/GijwKP.png)




### 8. ICMP 协议 

![img](https://s1.ax1x.com/2020/03/27/GijrVS.png)

<details>
<summary>展开查看</summary>
    <li>ICMP：在IP之上，用来测试网络层有没有故障。使用最多的命令是ping。
    </li>
    <li>为了提高IP数据报交付成功的机会，在网络层使用了ICMP(Internet Control Message Protocol)。 </li>
    <li>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告；</li>
    <li>ICMP不是高层协议，而是IP层协议；</li>
    <li>ICMP报文件为IP层数据报的数据加上数据报的首部，组成IP数据报发送出去。</li>
</details>


### 9. ICMP 报文的分类？ 

ICMP 分为两类，一类是 ICMP 查询报文，另一类是 ICMP 差错报文 

![1584976524622](https://s1.ax1x.com/2020/03/27/Gi2igs.png)



### 10. 网络层用来干嘛？传输层用来干嘛？

<details>
<summary>展开查看</summary>
    <li>网络层实现如何把数据包从这个地址(服务器)发送到另一个地址(服务器)。
    </li>
    <li>传输层实现如何让这个应用程序找到对应计算机的应用程序(相对应的应用程序实现逻辑通信)。 </li>
</details>


### 11. 为什么必须有IP，直接用mac不行吗；

<details>
<summary>展开查看</summary>
    <li>ip地址记录了终点地址，而MAC地址记录了下一跳的地址
    </li>
    <li>IP地址本质上是终点地址，在跳过路由器的时候不会改变，而MAC地址是下一跳的地址，每经过一个路由器都会改变。 </li>
</details>





## 传输层：TCP和UDP

### 1. 什么是TCP三次挥手

![1584759748649](https://s1.ax1x.com/2020/03/27/Gi2eET.png)

<details>
<summary>展开查看</summary>
    <p>
        我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功
    </p>
    <p>第一次握手：客户端将SYN（同步位）置为1， 随机产生了一个序列号seq发送给服务器端，进入SYN-SENT（同步已发送）状态</p>
    <p>第二次握手：服务器端收到客户端的的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK（确认位）置1，产生一个ack（确认号）=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD（同步已接收）状态</p>
    <p>第三次握手：客户端检查ack是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个ack=服务器发的序列号+1，发送给服务器；进入ESTABLISHED（连接已建立）状态；服务器检查ACK为1和ack为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</p>
</details>



### 2. TCP建立连接可以两次握手吗？为什么?

![1584759894352](https://s1.ax1x.com/2020/03/27/Gi2Q29.png)

<details>
<summary>展开查看</summary>
	<p>不可以两次握手,原因有2个：</p>
    <p>1. 可能会出现已失效的连接请求报文段又传到了服务器端。</p>
    <p> 如果发出的第一个请求连接没有丢失，只是可能因为网络问题发送的时间很长，导致连接已经释放之后才到达server。这个请求连接已经是一个失效的了。但是因为只有两次握手，只要客户端发出请求，服务端就会建立请求。就会一直等待客户端发来数据，客户端是一个失效的，不会向客户端发出数据了，这样客户端就一直等待，会造成资源浪费。
    <p>2. 两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</p>
</details>


### 3. 可以采用四次握手吗？为什么？

<details>
<summary>展开查看</summary>
	<p>可以。但是会降低传输的效率。</p>
    <p>四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p>
</details>


### 4. 第三次握手中，如果客户端的ACK未送达服务器，会怎样？

<details>
<summary>展开查看</summary>
    <p>如果服务器端一直没有收到ACK确认，服务器端会重发之前的ACK+SYN（默认重发次数为5），如果重发次数到达上限，服务器端还是没有确认，服务器端就会<b>自动关闭连接</b></p>
    <p>但是客户端会认为这个连接已经建立，如果这是客户端向服务器端发送数据，服务器端就会发送RST包进行相应。客户端就能知道服务器端产生了错误</p>
    <p>
        注意：RST包用来强制关闭TCP连接
    </p>
</details>


### 5. 如果已经建立了连接，但客户端出现了故障怎么办？

<details>
<summary>展开查看</summary>
    <p>如TCP还设有一个<b>保活计时器</b>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。</p>
    <p>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
</details>




### 6. 初始序列号是什么？

<details>
<summary>展开查看</summary>
    <p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；</p>
    <p>同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p>
</details>


### 7. 什么是四次挥手？

![1584760240310](https://s1.ax1x.com/2020/03/27/Gi2Gb6.png)

<details>
<summary>展开查看</summary>
    <p>我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧</p>
    <p>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1（终止等待1）状态；
	</p>
    <p>第二次挥手：服务器端收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；服务器端进入CLOSE_WAIT（关闭等待）状态。此时客户端已经没有要发送的数据了，客户端进入终止等待2状态，但仍可以接受服务器发来的数据。
	</p>
    <p>第三次挥手：服务器端将FIN置1，发送一个序列号给Client；进入LAST_ACK（最后确认）状态；
	</p>
    <p>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT（时间等待）状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</p>
</details>




### 8. 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？

<details>
<summary>展开查看</summary>
    <p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。这个时候表示客户端不会再向服务器端发送数据</p>
    <p>等到服务器端的数据发完之后再发FIN，断开服务器到客户端的数据传送。
    </p>
</details>





### 9. 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？

<details>
<summary>展开查看</summary>
    <p>客户端没有收到ACK确认，会重新发送FIN请求。
    </p>
</details>



### 10. 客户端TIME_WAIT状态的意义是什么？

<details>
<summary>展开查看</summary>
    <p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果客户端在2*MSL的时间内收到了服务器端的FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。
    </p>
	<p>
       MSL(Maximum Segment Lifetime)，中文是报文段最大生存时间。指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。 
    </p>
</details>



### 11. 为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢？

<details>
<summary>展开查看</summary>
    <p>TCP建立连接的时候，只需要前两步确认建立连接成功，第三次就可以传数据了
    </p>
	<p>
       而客户端在关闭连接时，仅代表客户端向服务器端的连接关闭了，可能服务器端还有要向客户端发送的数据。第三次挥手主要就是确认服务器端也没有向客户端发送的数据了，第四次客户端说我收到你给我发送的数据了，现在可以关闭了。 
    </p>
</details>



### 12. 4次挥手中，time_wait和close_wait的状态。

<details>
<summary>展开查看</summary>
    <p>
        TIME_WAIT 表示客户端主动关闭其时间长度是固定的2MSL，到期自动转为CLOSED，不会导致系统资源耗尽的问题。</p>
    <p>
        CLOSE_WAIT 表示服务器端被动关闭。CLOSE_WAIT（关闭等待）出现在服务器接受到客户端的FIN消息之后
    </p>
    <p>
        CLOSE_WAIT状态在服务器端向客户端发送FIN消息之后转换成下一个状态即LAST_ACK（最终确认）状态。
    </p>
    <p>
        如果服务器端一直没有向客户端发送FIN消息(调用close() API)，那么这个CLOSE_WAIT会一直存在下去。
    </p>
</details>


### 13. TCP 的三次握手 以及过程中 的syn, ack, seq

<details>
<summary>展开查看</summary>
    <p>
        第一次握手：客户端向服务器端进行连接请求，syn=1，随机生成一个seq = x，客户端的状态为SYN-SENT（同步已发送）状态
    </p>
    <p>
        第二次握手：服务器端对客户端进行连接响应。ACK=1, syn=1，随机生成一个seq = y， ack = x+1， 因为syn占一字节，此时客户端的状态为SYN-RCVD(同步已接收)状态
    </p>
    <p>
        第三次握手：客户端向服务器端发送TCP确认，ACK=1, seq = x + 1, ack = y + 1, 
    </p>
</details>





### 14. 如果一个客户端不理会服务端发来的ack，一直重发syn怎么办？

<details>
<summary>展开查看</summary>
    <p>
       SYN包也就是握手包，客户端一直发送连接请求，但是不理会回应，在服务器端就是产生大量的半连接状态，会塞满整个TCP队列，导致资源耗尽，其他的服务连接请求也进不来
    </p>
    <p>
        在我的理解中，这个syn洪水攻击很像，其中一个应急方法就是用netstat查看对方ip的特征 `netstat -na |grep SYN_RECV|more` 找到这个最大嫌疑ip的号段，直接杀死进程
    </p>
    <p>
        也可以使用SYN COOKIE防火墙，在收到客户端的SYN请求时，防火墙扮演服务器的角色回应一个带有SYN cookie的SYN-ACK包给客户端。度过客户端返回SYN的话，由防火墙转发C和S之间的数据。
    </p>
</details>




### 15. SYN洪水攻击原理

<details>
<summary>展开查看</summary>
    <ol>
       原理：
        <li>Client伪造大量的虚假ip,向Server发送SYN包</li>
        <li>Server在接收到SYN包后,会返回响应,并进入SYN_RECV状态,等待客户端的确认</li>
        <li>但是伪造的ip肯定不会给予响应,于是Server以为数据包丢失,不断重发,直到超时</li>
    </ol>
   	<p>
        危害：这些伪造的SYN会长期占用未连接队列，是真正的请求无法加入队列而被丢弃，引起网络拥塞甚至网络瘫痪
    </p>
	<p>
    如何确认是SYN攻击：当服务器上有大量的半连接且ip为随机的,可以确认是SYN攻击
    </p>
    <p>
        查出方法：
        <code>
            netstat -nap | grep SYN_RECV
        </code>
    </p>
</details>


### 16. TCP如何实现流量控制？

![1584892383885](https://s1.ax1x.com/2020/03/27/Gi25Mn.png)

<details>
<summary>展开查看</summary>
    <p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。
    </p>
    <p>
        接收端先发，发送端根据接收端的窗口尺寸确定发送端窗口尺寸。
    </p>
	<p>
       接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。<b>发送窗口的大小不能超过接受窗口的大小</b>，只有当发送方发送并收到确认之后，才能将发送窗口右移。
    </p>
    <p>
       发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。 
    </p>
</details>



### 17. 什么是零窗口（接收窗口为0时会怎样）？

<details>
<summary>展开查看</summary>
    <p>如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，同时会启动一个坚持计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。
    </p>
</details>



### 18. TCP的拥塞控制是怎么实现的？

![1584757862678](https://s1.ax1x.com/2020/03/27/GiRARH.png)

拥塞控制主要由四个算法组成：**慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）**

1. 慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，拥塞窗口的大小就会加倍。1，2，4，8，16，32这样加倍

   ![1584923512734](https://s1.ax1x.com/2020/03/27/GiRtLq.png)

2. 拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，**拥塞窗口大小不再指数增加，而是线性增加**，即每经过一个传输轮次只增加1MSS.

   > 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。**（这是不使用快重传的情况）**

3. 快重传：快重传要求接收方在收到一个失序的报文段后就立即发出**重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。**快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期**。

   ![1584923875087](https://s1.ax1x.com/2020/03/27/GiRdoT.png)

4. 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。**不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞**。
   也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。



### 19. TCP与UDP的区别

1. TCP是面向连接的，UDP是无连接的；

<details>
<summary>什么叫无连接？</summary>
    <p>UDP发送数据之前不需要建立连接
    </p>
</details>

2. TCP是可靠的，UDP不可靠；

<details>
<summary>什么叫不可靠？</summary>
    <p>UDP接收方收到报文后，不需要给出任何确认
    </p>
</details>


3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
4. TCP是面向字节流的，UDP是面向报文的；

<details>
<summary>什么意思？</summary>
    <p>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
    </p>
</details>

5. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；

6. TCP首部开销（20字节）比UDP首部开销（8字节）要大

   ![1584714196525](https://s1.ax1x.com/2020/03/27/GiRyl9.png)

   ![1584716309043](https://s1.ax1x.com/2020/03/27/GijT54.png)

7. UDP 的主机不需要维持复杂的连接状态表



### 20. 什么时候选择TCP，什么时候选UDP？

<details>
<summary>展开查看</summary>
    <p>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；
    </p>
    <p>
        其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失
    </p>
</details>

### 21. HTTP可以使用UDP吗？

<details>
<summary>展开查看</summary>
    <p>HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠。HTTP传输的文件不能随便出错。
    </p>
</details>



### 22. 面向连接和无连接的区别

<details>
<summary>展开查看</summary>
    <p>
        无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）
    </p>
    <p>
        1. 虚电路服务:一条虚电路包括源和目的主机之间的路径（一系列链路和路由器）、VC（virtual circuit）（虚电路）号，沿着该路径的每段链路的号码、以及该路径上每台路由器中的转发表。
    </p>
    <p>
        属于一条虚电路的分组将在它的首部携带一个VC号。一条虚电路在每条链路上可能具有不同VC号，故每台中间路由器必须用一个新的VC号替代每个传输分组的VC 号。该新的VC号从转发表获得。
    </p>
    <p>
        <b>
            首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；
        </b>
    </p>
    <p>
        2. 数据报网络：是网络层无链接的服务。端系统每要发送一个分组，就为该分组加上目的端系统的地址，然后将该分组推进网络。数据报网路中不维护连接状态信息，但有转发状态信息。每个路由器使用一个分组的目的地址来转发该分组。路由器匹配目的地址时，使用最长前缀匹配规则。转发表大概每1~5分钟由路由算法更新一次。
    </p>
    <p>
        <b>
        每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；
        </b>     
    </p>
</details>

![1584924653675](https://s1.ax1x.com/2020/03/27/GiRcO1.png)

### 23. TCP如何实现可靠性传输？

<details>
<summary>展开查看</summary>
    <p>1. 数据包校验
    </p>
    <p>
        2. 对失序数据包重新排序（TCP报文具有序列号）
    </p>
    <p>
        3. 丢弃重复数据
    </p>
    <p>
		4. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
    </p>
    <p>
        5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
    </p>
    <p>
        6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出
    </p>
</details>


### 24. 王者荣耀是基于TCP还是UDP，为什么。

<details>
<summary>展开查看</summary>
    <p>王者荣耀这种MOBA(多人在线战术竞争游戏)是采用udp的，包括腾讯多数长链接手游都是采用udp。原因：
    </p>
    <p>
        1. tcp保证数据可靠性是有代价的：在TCP中，只要数据包出错，就必须等待数据包的重发。
    </p>
	<p>
       如果遇到网络环境太差或者不稳定，比如说国内的移动网络，或者是遭遇到了网络阻塞，出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，玩家操作会出现卡顿以及响应不及时的现象。
    </p>
    <p>
       2. udp的可靠性—DIY手动组装
    </p>
    <p>
        说udp是不可靠的，主要是因为udp不能保证接收包的顺序，也不能保证丢包的情况。如果把这两个问题解决了，那么udp的大部分可靠性问题也都解决了。
    </p>
    <p>
        游戏中常见的同步方案，有状态同步和帧同步，一般大型的MMOARPG都是采用的是状态同步，比如魔兽世界，状态同步采用C/S架构，所有的状态由服务器来控制，安全性比较高，但是流量比较大。<b>帧同步采用的是囚徒模式，所有c端强制采用一个逻辑帧率，从而保证输出一致，其特点是流量小，安全性比较差。</b>
    </p>
    <p>
        <b>王者荣耀采用的就是帧同步。帧同步所有计算和逻辑均在客户端进行，不同步状态，只同步操作指令。</b>就是说如果玩家A网速慢，他有可能直接被网速快的B秒了。玩家A不会卡到玩家B的操作，只会感觉自己的操作有延迟而已。（可能画面瞬移，你就死了）
    </p>
</details>

|        | TCP        | UDP          |
| ------ | ---------- | ------------ |
| 连接   | 面向连接   | 非连接       |
| 可靠性 | 可靠、有序 | 不可靠、无序 |
| 数据包 | 自动拆包   | 手动拆包     |
| 流量   | 流量控制   | 手动         |
| 速度   | 慢         | 快           |
| 控制   | 简单       | 复杂         |

![帧同步示意图](https://s1.ax1x.com/2020/03/27/GijXKx.png)



### 25. 拥塞控制，流量控制针对的分别是什么问题

![](https://s1.ax1x.com/2020/03/27/Gijjr6.png)



<details>
<summary>拥塞控制</summary>
    <p>
      拥塞控制防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。<b>拥塞控制处理网络能够承受现有的网络负荷，拥塞控制是一个全局性的过程。</b>
    </p>
    <p>
      作用：避免给整体的网络造成较大的堵塞  
    </p>
    <p>
       当我们每个人都在高速上网时，可能因为并发量太大，数据太多，导致链路压力太大，最后大家网速都不咋地，类似于过节开车上高速堵住一样。 
    </p>
    <p>
       发送方会维持一个拥塞窗口（动态变化），拥塞窗口的大小代表着网络的拥塞程度。<b>发送方的滑动窗口小于等于该拥塞窗口。 </b>
    </p>
</details>



<details>
<summary>流量控制</summary>
    <p>
      <b>流量控制是发送端和接受端之间的点对点通信量的控制</b>，是一个端到端的问题，主要就是抑制发送端发送数据的速率，以便接收端来得及接收。
    </p>
    <p>
      实现原理：通过滑动窗口就可以实现，是接收方告知发送方自己的窗口大小，发送方立刻更改即可实现流量控制。这是让发送方维护一个接受窗口的流量来控制的
    </p>
</details>


### 26. 对tcp有什么看法，觉得他有什么弊端、风险，可以怎么优化

<details>
<summary>展开查看</summary>
    <p>
      TCP是面向连接的，可靠的传输。TCP的传输是字节流的形式，就是说对于大数据包而言TCP会进行分段传输。TCP首部有序号，可以保证数据包的顺序。对丢包有重传机制。有流量控制和利用滑动窗口技术实现的拥塞控制。
    </p>
    <p>
        但是这种可靠传输也有弊端，就是每次传输的速度很慢。tcp协议上有一个缺陷能会造成syn洪水攻击。如果大量伪造的ip地址向客户端发出SYN连接请求，很有可能会让cpu的资源耗尽。
    </p>
    <p>
        对于syn洪水攻击的优化方法可以使用SYN Cookie防火墙技术优化。
    </p>
</details>


### 27. 建立一个简单的tcp服务器的过程

<details>
<summary>展开查看</summary>
    <p>
      TCP通信需要经过创建连接、数据传输、终止连接三个步骤。
    </p>
    <ol>
        创建tcp服务器的流程:
        <li>创建一个socket套接字</li>
        <li>绑定服务器的IP和端口port</li>
        <li>开启监听listen将服务器的主动连接变成被动连接。 </li>
        <li>等待客户端的请求连接</li>
        <li>接收客户端的数据请求，向客户端发送数据 </li>
    </ol>
    <p>
        tcp服务端一般情况下要绑定端口，否则客户端会找不到服务器
    </p>
    <p>
        tcp客户端一般不需要绑定，因为是主动连接服务器
    </p>
</details>


### 28. 传视频用UDP，说说为什么？

<details>
<summary>展开查看</summary>
    <p>
      TCP传数据的速度太慢了，用户可以忍受丢帧，但是不能忍受漫长等待。
    </p>
    <p>
        tcp要三次握手，四次挥手，丢包要重传，还有拥塞控制和流量控制。
    </p>
</details>



### 29. UDP包大小是多少？TCP的呢？
<details>
<summary>展开查看</summary>
	<p>
	以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的，这个1500字节被称为链路层的MTU(最大传输单元)。 前面是以太网的MTU=1500 ， Internet的MTU为576字节。
	</p>
    <p>
      以太网 UDP 包（MSS）的大小应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)
    </p>
    <p>
      以太网 TCP 包（MSS）的大小应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)。 Internet TCP 包（MSS）的大小为536 (Bytes)字节
    </p>
</details>



### 30. 讲一下接收窗口

<details>
<summary>展开查看</summary>
	<p>
	接收窗口的大小决定了发送窗口的大小
如果发生丢包，接收窗口向发送窗口返回丢失的ACK， 并让发送窗口重新发包
	</p>
</details>





### 31. tcp/udp，tcp中发生大量丢包的情况下，会发生什么情况

<details>
<summary>展开查看</summary>
	<p>
	tcp中有流量控制，如果发生了大量丢包，可能是内存不足或者处理能力不够。我个人认为就是将接收窗口置为0，告诉发送窗口暂停数据流的传输。同时开启坚持计时器。在计时器有效时间内，如果服务器能够再次处理数据，就会返回非零的窗口大小，再去处理丢包。用重传技术。
	</p>
</details>


### 32. tcp 怎么保证数据包有序

<details>
<summary>展开查看</summary>
	<p>
	每次在传输数据的时候，TCP会给每个数据包分配一个序列号并且会启动一个重传定时器，在超时时间段内等待接收方，也就是服务器端对序列号进行确认。
	</p>
    <p>
        如果客户端重传定时器截止之前收到了对此报文段的确认，就撤销计时器，如果没收到，就重传此包
    </p>
    <p>
        接收方利用序列号对接收的数据进行确认，以便检测发送方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到应用层进行处理。
    </p>
</details>





### 33. 四次挥手之后为什么还要等待2msl

<details>
<summary>展开查看</summary>
	<p>
	等待2msl是防止客户端发送的最后一个ACK包没有被服务器端收到，超时后服务器端如果没有收到ACK包，服务器端就会重发FIN包。重新应答
	</p>
    <p>
        处在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。这样是为了防止有迟到的报文段请求连接。这种迟到的报文段应该直接丢弃。
    </p>
</details>



### 34. 滑动窗口机制的原理和理解

<details>
<summary>展开查看</summary>
	<p>
	原理：滑动窗口原理就是发送端和接收端各维护一个接收窗口和一个发送窗口。接收窗口维护自己接收到的数据，发送窗口负责处理自己要发送出去的数据。以达到流量控制的目的。
	</p>
    <p>
        理解：有了滑动窗口，通信双方就不用发送一个报文后，收到此报文的确认后再发送下一个报文，而是可以连续发送多个报文，只要别超过窗口大小限制
    </p>
</details>


### 35. 讲讲TCP慢启动，

<details>
<summary>展开查看</summary>
	<p>
	刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值（1），每收到一个新的确认报文之后，拥塞窗口的大小就会加倍。1，2，4，8，16，32这样加倍。直到达到慢开始门限
	</p>
</details>





### 36. 客户端服务端滑动窗口大小如何协商。

<details>
<summary>展开查看</summary>
	<p>
		滑动窗口通俗来讲就是一种流量控制技术。
	</p>
    <p>
        第一次发送数据的窗口大小是根据链路带宽的大小来决定的。
    </p>
    <p>
        当链路变好或者变差，如果网络好，接收窗口的右边界会扩大；如果差，就会缩小。
    </p>
    <p>
        接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。
    </p>
</details>




### 37. 握手时产生的序列号干什么用的

<details>
<summary>展开查看</summary>
	<p>
	    在tcp通信中，发送方发送任何消息，都必须带上序列号，
	</p>
	<p>
	    同时，接收方必须返回确认号，确认号是序列号+1（除了建立链接第一次握手的时候），这样，双方就能保证数据不丢失。
	</p>
</details>


### 38. TCP和UDP分别对应的常见应用层协议

![](https://s1.ax1x.com/2020/03/27/GijzVO.png)

<details>
<summary>展开查看</summary>
	<ol>
	    TCP对应的应用层协议:
        <li>FTP：定义了<b>文件传输协议</b>，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li>
        <li>Telnet：它是一种<b>用于远程登陆的端口</b>，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</li>
        <li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，<b>用于发送邮件</b>。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</li>
        <li>POP3：<b>它是和SMTP对应，POP3用于接收邮件</b>。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</li>
        <li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</li>
	</ol>
	<ol>
        UDP对应的应用层协议:
        <li>DNS：用于<b>域名解析服务，将域名地址转换为IP地址。</b>DNS用的是53号端口。
</li>
        <li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
        <li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li>
    </ol>
</details>


### 39. UDP为什么要加有伪首部？

<details>
<summary>展开查看</summary>
	<p>
	    目的是让 UDP 两次检查数据是否已经正确到达目的地。
	</p>
	<p>
	    IP 接受正确的目的地址，传送到正确的上层程序。
	</p>
    <p>
		所有伪首部包括：源 IP 地址，目的 IP 地址， 0，协议号， UDP 长度。
    </p>
</details>

![1584977065147](https://s1.ax1x.com/2020/03/27/GiRhFO.png)



## 应用层：HTTP和HTTPS

### 1. HTTP与HTTPS的区别

<details>
<summary>展开查看</summary>
	<p>
	    1. HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。
	</p>
	<p>
	    2. 端口也不一样，HTTP是80，HTTPS是443。
	</p>
    <p>
		3. HTTPS由于加密解密会带来更大的CPU和内存开销；
    </p>
	<p>
		4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买。SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
	</p>
</details>


### 2. Https的连接过程？

![1584958589979](https://s1.ax1x.com/2020/03/27/GiRL0P.png)

<details>
<summary>展开查看</summary>
	<ol>HTTP主要有三个缺点导致其不安全：
        <li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li>
        <li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li>
        <li>客户端验证服务器的合法性，包括：证书是否过期，CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li>
        <li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<b>随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）</b>；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li>
        <li>服务器使用自己的<b>私钥解密</b>，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li>
        <li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li>
	</ol>
<p>
     总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。
    </p>
</details>



### 3. HTTPS为什么安全

<details>
<summary>展开查看</summary>
	<ol>Https的连接过程:
        <li>通信使用<b>明文</b>（不加密），内容可能会被窃听</li>
        <li><b>不验证通信方的身份</b>，因此有可能遭遇伪装</li>
        <li><b>无法证明报文的完整性</b>，所以有可能已遭篡改</li>
	</ol>
<p>
     HTTPS之所以比HTTP安全，是因为它利用SSL(安全套接层)/TSL(传输层安全协议)协议传输，保障了传输过程的安全性。
    </p>
</details>

![](https://s1.ax1x.com/2020/03/27/GivEsP.png)





### 4. CA 证书

<details>
<summary>展开查看</summary>
<p>
     证书颁发机构（CA, Certificate Authority）是PKI系统中通信双方信任的实体，被称为可信第三方（Trusted Third Party，简称TTP）。CA证书，顾名思义，就是CA颁发的证书。
    </p>
    <p>
        CA的初始是为了解决上面非对称加密被劫持的情况，服务器申请CA证书时将服务器的“公钥”提供给 CA，CA使用自己的“私钥”将“服务器的公钥”加密后（即：CA证书）返回给服务器，服务器再将“CA证书”提供给客户端。一般系统或者浏览器会内置CA的根证书（公钥），
    </p>
</details>

- HTTPS 中 CA 证书的获取

![](https://s1.ax1x.com/2020/03/27/GivVqf.png)

### 5. Cookie 和 Session 的区别

<details>
<summary>展开查看</summary>
	<li>
     cookie数据存放在客户的浏览器上，session数据放在服务器上
        <p>
            session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能
考虑到减轻服务器性能方面，应当使用cookie。
        </p>
    </li>
    <li>
	session比cookie更安全
        <p>
			cookie不是很安全，可以通过分析存放在本地的cookie并进行cookie欺骗。
        </p>
    </li>
    <li>一般用cookie来存储session id。
        <p>
            如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）
        </p>
    </li>
    <ol><b>建议</b>：
    <li>将登录信息等敏感信息存放为session</li>
	<li>其他信息如果需要保留，可以放在cookie中</li></ol>
  </details>



### 6. Http是无状态为什么还能识别客户端

<details>
<summary>展开查看</summary>
	<li>HTTP无状态协议是指协议对于<b>事务处理没有记忆能力。</b>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</li>
    <li>现在网站上会使用cookie和session来辅助服务器。</li>
    <li>sessionid是服务器端用来识别客户端，也就是知道是哪个客户端发来的数据，响应给哪个客户端。</li>
    <li>某个用户如果登录成功，这个用户的id和相关信息就会保存至session中，这样通过sessionid 就可以找到session。</li>
    <li>关闭浏览器、长时间没有请求服务器、注销登陆，这个时候服务器会把该sessionid从内存中清除掉，这个时候如果我们再去请求服务器，sessionid已经不存在了，所以服务器并没有在内存中找到对应的 sessionid，所以会再产生一个新的sessionid，这个时候一般我们又要再登录一次。</li>
    <li>而我们关注这个客户端是哪个用户在使用，所以需要在服务器端生成标识哪个用户的session，以便做相应处理。</li>
</details>

![img](https://s1.ax1x.com/2020/03/27/Giv8s0.png)



### 7. SSL与TLS有什么区别？

<details>
<summary>展开查看</summary>
	<p>
	    SSL(Secure Sockets Layer 安全套接层),及其更优秀的继承者传输层安全（Transport Layer Security，TLS）。俩者是为网络通信提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层对网络连接进行加密。
	</p>
	<ol>
        区别：
        <li>SSL与TLS两者所使用的算法是不同的</li>
        <li>2. TLS增加了许多新的报警代码，比如解密失败(decryption_failed)、记录溢出(record_overflow)、未知CA(unknown_ca)、拒绝访问(access_denied)等，但同时也支持SSL协议上所有的报警代码!</li>
        <li>TLS是SSL的不兼容增强版。即TLS和SSL不能共用</li>
    </ol>
</details>



### 8. 一次完整的 HTTP 请求所经历的步骤 

比如：在浏览器中输入 www.baidu.com 后执行的全部过程 

1. 客户端浏览器通过**DNS**解析到www.baidu.com 的IP地址220.181.27.48， 通过这个路径找到客户端到服务器的路径。客户端浏览器发起一个**HTTP会话**到220.181.27.48，然后通过**TCP**进行封装数据包，输入到网络层。
2. **在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口。**如服务器使用80端口监听用户端的请求，客户端由系统随机选择一个端口如5000，与服务区进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
3. 客户端的**网络层**不用管应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，就是通过查找路由表决定通过哪个路径到达服务器。
4. 客户端的**链路层**，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。



### 9. 什么是DNS协议

<details>
<summary>展开查看</summary>
<p>
     DNS协议就是域名解析协议，将域名解析为ip地址。
    </p>
    <p>
        DNS 协议运行在 UDP 协议之上，使用端口号 53
    </p>
</details>




### 10. DNS主机解析域名的顺序 

<details>
<summary>展开查看</summary>
    <ol>
        <li>浏览器缓存</li>
        <li>找本机的 hosts 文件</li>
        <li>路由缓存</li>
        <li>找 DNS 服务器(本地域名、顶级域名、根域名)：（实现算法）迭代查询、递归查询</li>
    </ol>
</details>




### 11. 网络层和运输层的主要区别

<details>
<summary>展开查看</summary> 
        <li>网络层提供点到点（IP就是IP）的通信服务。负责IP数据报的产生以及IP数据包在逻辑网络上的路由转发</li>
        <li>传输层提供端到端（端口号到端口号）通信服务层次，提供可靠及非可靠连接</li>
        <li>网络层把货物打包，传输层打开一条路</li>
        <li>这样数据报就能到达目的地了</li>
</details>


 

### 12.  GET和POST的区别

| 场景                           | GET                                                          | POST                       |
| ------------------------------ | ------------------------------------------------------------ | -------------------------- |
| **浏览器回退**                 | 无害的                                                       | 会重复提交请求             |
| 产生的URL地址                  | 可以被收藏                                                   | 不可以                     |
| **浏览器缓存**                 | 主动缓存                                                     | 不会自动缓存，除非手动设置 |
| 编码方式                       | 只能进行URL编码                                              | 支持多种编码方式           |
| **浏览器历史记录中的请求参数** | 完整保留                                                     | 不会保留                   |
| **URL中传递的参数长度**        | 2KB左右，不同浏览器限制不同。故参数不要太长，容易被浏览器截断。 | 没有限制                   |
| 参数的数据类型                 | ASCII字符                                                    | 没有限制                   |
| 安全性                         | 参数直接暴露在URL上，还可能造成CSRF攻击（以?分割URL和传输数据，多个参数用&连接） | 可以传递敏感信息           |
| **参数传递**                   | URL传递                                                      | Request body中             |



### 13. http的报文结构，问我知道有哪些报文头

![1584762980117](https://s1.ax1x.com/2020/03/27/GiWn1J.png)

1. 请求行

   - 请求方式：POST、GET
   - 请求的资源：/DemoEE/form.html
   - 协议版本：HTTP/1.1（一般都是）
   - HTTP/1.0，发送请求，创建一次连接，获得一个web资源，连接断开。
   - HTTP/1.1，发送请求，创建一次连接，获得多个web资源，保持连接。

2. 请求头

   请求头是客户端发送给服务器端的一些信息，使用键值对表示key：value

   | 常见请求头        | 描述                                                         |
   | ----------------- | ------------------------------------------------------------ |
   | Referer           | 浏览器通知服务器，当前请求来自何处。如果是直接访问，则不会有这个头。常用于：防盗链 |
   | If-Modified-Since | 浏览器通知服务器，本地缓存的最后变更时间。与另一个响应头组合控制浏览器页面的缓存。 |
   | **Cookie**        | 与会话有关技术，用于存放浏览器缓存的cookie信息。             |
   | **User-Agent**    | 浏览器通知服务器，客户端浏览器与操作系统相关信息             |
   | Connection        | 保持连接状态。Keep-Alive 连接中，close 已关闭                |
   | Host              | 请求的服务器主机名                                           |
   | Content-Length    | 请求体的长度                                                 |
   | Content-Type      | 如果是POST请求，会有这个头，默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码 |
   | Accept：          | 浏览器可支持的MIME类型。文件类型的一种描述方式。MIME格式：大类型/小类型[;参数]例如：   text/html ，html文件   text/css，css文件   text/javascript，js文件   image/*，所有图片文件 |
   | Accept-Encoding   | 浏览器通知服务器，浏览器支持的数据压缩格式。如：GZIP压缩     |
   | Accept-Language   | 浏览器通知服务器，浏览器支持的语言。各国语言（国际化i18n）   |

3. 请求体

   - 当请求方式是post的时，请求体有请求的参数，格式如下：

   ```
   username=zhangsan&password=123
   ```

   - 如果请求方式为get，那么请求参数不会出现在请求体中，会拼接在url地址后面

     ```
     http://localhost:8080...?username=zhangsan&password=123
     ```

   - 能看到请求体，提交方式就是post，看不到就是get；get的请求数据在请求行中；

   - 判断客户端是什么浏览器，看http请求头User-Agent里的浏览器：MSIE,FireFox等





### 14. 什么是对称加密、非对称加密？区别是什么？

<details>
<summary>展开查看</summary> 
        <li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4</li>
        <li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA</li>
        <li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）</li>
</details>





### 15. 数字签名、报文摘要的原理

[阮一峰老师的图解数字签名，很好理解](<http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html>)

<details>
<summary>展开查看</summary> 
        <li>报文摘要：用于对发送的报文生成一个非常小的摘要信息。这个摘要信息保证原报文的完整性，即原报文只要有一位被改变，则摘要信息就会不匹配。可以用Hash函数加密报文摘要</li>
        <li>数字签名：用于对发送的报文进行签名。主要使用公开密钥加密系统实现，如RSA；发送者通过私钥加密，接收方通过公秘解密。</li>
    <li>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文</li>
    <li>两者采用的算法不同，数字签名主要是利用公钥算法，常见的有HASH、DSS和RSA签名。</li>
    <li>报文摘要主要是安全散列标准，常用SHA-1和MD5等。</li>
</details>


### 16. https的具体实现过程。(就是中间客户端、服务器、CA三方的交互过程)

![img](https://s1.ax1x.com/2020/03/27/Giv0zR.png)

<details>
<summary>展开查看</summary> 
        <li>客户端向服务器端发送请求连接</li>
        <li>服务器端将自己公钥发送给CA（证书中心），CA用自己的私钥给服务器端的公钥和其他信息进行加密，并将自己的公钥发送给客户端</li>
    <li>之后服务器端将数字证书发送给客户端，客户端检查数字证书是由有效</li>
    <li>如果有效的话服务端会生成一个随机数R，并使用CA的公钥对R进行加密。</li>
    <li>客户端将加密的R传送给服务器。</li>
    <li>服务器用自己的私钥解密得到R。</li>
    <li>服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。</li>
    <li>客户端以R为密钥使用之前约定好的解密算法获取网页内容。
</li>
</details>




### 17. 说说中间人攻击的过程

[快速理解https实现的原理](<https://www.jianshu.com/p/35f78893aa50>)
<details>
<summary>展开查看</summary> 
        <li>客户端发起SSL握手请求，这是中间人劫持用户请求，之后中间人伪装客户端发起SSL握手</li>
        <li>服务器本来向客户端发送的公钥被中间人拿到，中间人给客户端发送一个中间人的公钥（也就是伪造公钥）</li>
    <li>客户端利用接收到的伪造公钥对数据进行加密，发送对称密钥</li>
    <li>中间人就可以用自己的私钥，解密出对称密钥，之后中间人利用服务器发送的正确公钥，加密对称密钥，发送给服务器</li>
    <li>后去服务器和客户端发送的认可数据，都用对称密钥加密，中间人就可以获取到所有的信息</li>
</details>

### 18. http有哪些版本，1.0和1.1有什么区别。

<details>
<summary>HTTP/0.9</summary> 
        <li>只有一个命令GET</li>
        <li>没有 header 等描述数据的信息</li>
    	<li>服务器发送完毕，就关闭TCP连接</li>
</details>

<details>
<summary>HTTP/1.0</summary> 
        <li>HTTP1.0 增加为三种请求方法： GET, POST 和 HEAD方法。</li>
        <li>增加了status code 和 header</li>
    	<li>多字符集支持、多部分发送、权限和缓存等</li>
</details>

<details>
<summary>HTTP/1.1</summary> 
        <li>持久连接</li>
    	<li>新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</li>
        <li>pipeline</li>
    	<li>增加 host （可以在一个集群上同时跑多个web服务，通过host字段来判断使用node还是Java服务，提高物理服务的使用效率）和其他一些命令</li>
</details>

<details>
<summary>HTTP/2.0</summary> 
        <li>分帧传输：所有数据以二进制（帧）传输，之前都是用字符串</li>
        <li>多路复用(信道复用)：同一个连接中发送多个请求，不再需要按照顺序来</li>
    	<li>头信息压缩（之前都是完整发送和返回，占用带宽的量比较大）以及推送（支持server push，即服务端可以主动发送数据传输）等提高效率的功能</li>
</details>


### 19. AES加密的具体过程。

![img](https://s1.ax1x.com/2020/03/27/GivWJH.png)

<details>
<summary>展开查看</summary> 
    <p>
        高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法
    </p>
    <ol>具体的加密流程：
        <li>发送方将密钥和明文用AES加密函数加密成密文，通过网络传输给接收方</li> 
        <li>接收方将密钥和密文使用AES解密函数解密成明文。</li>
    </ol>
</details>





### 20. http请求都有什么？

<details>
<summary>展开查看</summary> 
    <table>
    	<tr><th>HTTP方法名</th><th>作用</th></tr>
    	<tr><td>GET</td><td>获取资源</td></tr>
        <tr><td>POST</td><td>更新/修改资源</td></tr>
        <tr><td>PUT</td><td>获取资源</td></tr>
        <tr><td>DELETE</td><td>删除资源</td></tr>
        <tr><td>HEAD</td><td>获得报文首部</td></tr>
        <tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr>
        <tr><td>OPTIONS</td><td>返回服务器针对特定资源所支持的HTTP请求方法，允许客户端发送'*'查看服务器的性能</td></tr>
        <tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr>
    </table>
</details>



### 21. http和https的区别，哪个快？两个的端口是什么？

<details>
<summary>展开查看</summary> 
        <li>http不安全，https是使用了SSL/TSL的安全超文本传输协议</li>
        <li>HTTP快，因为https要进行安全验证</li>
    	<li>http的端口是80 https的端口是443</li>
</details>





### 22. http cookie具体所有相关内容

[Cookie和session应该这样理解](<https://zhuanlan.zhihu.com/p/59307179>)

<details>
<summary>展开查看</summary> 
    <li>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li>    
    <li>Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</li>
        <li>Cookie存在于客户端里面，所以它是可以被我们浏览器（客户机）给清除掉的。</li>
    <li>Cookie的作用，就是在该用户登录成功之后，将登录状态“种”在客户机，下次以HTTP请求的方式带过来。那么，该用户之后的操作都可以基于“已经登录成功”的状态上进行。</li>
</details>



### 23. 浏览器怎么缓存？

[彻底理解浏览器缓存机制](<https://juejin.im/entry/5ad86c16f265da505a77dca4>)

![img](https://s1.ax1x.com/2020/03/27/GivIyt.png)

<details>
<summary>展开查看</summary> 
    	<li>浏览器向浏览器缓存发出HTTP请求</li>
    	<li>浏览器缓存分为强制缓存和协商缓存</li>
        <li>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)</li>
        <li>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；</li>
    	<li>生效则返回304，继续使用缓存</li>
    	<li>最后返回缓存结果，页面加载成功</li>
</details>




### 24. 讲一下http的状态码，200，400这些不要说（这个我是直接举了个delete操作的例子，从它会遇到的各种情况去讲相应的返回码的）

<details>
<summary>展开查看</summary> 
    <h3>消息响应</h3>
    <table>
    	<tr><th>状态码</th><th>说明</th><th>详情</th></tr>
    	<tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其他部分</td></tr>
        <tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr>
    </table>
    <h3>成功响应</h3>
    <table>
    	<tr><th>状态码</th><th>说明</th><th>详情</th></tr>
    	<tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr>
        <tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr>
       <tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理</td></tr>
        <tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一个源</td></tr>
        <tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分请求</td></tr>
    </table>
    <h3>重定向</h3>
    <table>
    	<tr><th>状态码</th><th>说明</th><th>详情</th></tr>
    	<tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作</td></tr>
        <tr><td>301</td><td>永久移动</td><td>请求的网页已<b>永久</b>移动到新位置，即永久重定向</td></tr>
        <tr><td>302</td><td>临时移动</td><td>请求的网页<b>暂时</b>跳转到其他页面，即暂时重定向</td></tr>
        <tr><td>303</td><td>查看其他位置</td><td>如果原来的请求是POST，重定向目标文档应该通过GET提取。总是使用GET请求新的URL</td></tr>
        <tr><td>304</td><td>未修改</td><td>此次请求返回的页面未修改，服务器告诉客户原来缓存的文档还可以继续使用</td></tr>
        <tr><td>305</td><td>使用代理</td><td>请求者应该使用代理访问该页面</td></tr>
        <tr><td>307</td><td>临时重定向</td><td>临时性重定向，除GET、HEAD方法外，其他的请求方法必须等客户确认才能跳转</td></tr>
    </table>  
    <h3>客户端错误</h3>
    <table>
    	<tr><th>状态码</th><th>说明</th><th>详情</th></tr>
    	<tr><td>400</td><td>错误请求</td><td>客户端有语法错误，不能被服务器所理解</td></tr>
        <tr><td>401</td><td>未授权</td><td>请求没有进行身份验证或验证未通过，这个状态码必须和WWW-Authenticate报头域一起使用</td></tr>
        <tr><td>403</td><td>禁止访问</td><td>对被请求页面的访问被禁止</td></tr>
        <tr><td>404</td><td>未找到</td><td>服务器找不到请求的页面</td></tr>
    </table>
    <h3>服务器端错误</h3>
    <table>
    	<tr><th>状态码</th><th>说明</th><th>详情</th></tr>
    	<tr><td>500</td><td>服务器内部错误</td><td>一般来说，这个问题都会在服务器端的源代码出现错误时出现</td></tr>
        <tr><td>502</td><td>错误网关</td><td>从上游服务器接收到无效的响应</td></tr>
        <tr><td>503</td><td>服务不可用</td><td>请求未完成，服务器临时过载或宕机（可能是过载或正在维护），一段时间后可能恢复正常。看Retry-After头，可以预计延迟时间，如果没给出Retry-After头，那么客户端应当以处理500响应的方式处理它</td></tr>
        <tr><td>504</td><td>网页请求超时</td><td>访问大流量或者内容数据量较多的网站。根据我们掌握的服务器性能状况及网络流量情况，合理的对nginx.conf中的字句进行合理正确的设置。</td></tr>
        <tr><td>505</td><td>HTTP版本不支持</td><td>服务器不支持请求中所用的HTTP协议版本</td></tr>
    </table>
</details>



### 25. 如何保证一个api的安全性（从后端的权限设定到http攻击都可以讲，不过面试官期望直接讲http攻击，这个不会）
<details>
<summary>展开查看</summary> 
    	<li>通信使用https</li>
    	<li>请求签名，防止参数被篡改</li>
        <li>对所有请求和响应都进行加解密操作</li>
</details>


### 26.  你听过哪些http攻击（这里我知道的不多，只举了一个例子结合讲了一下CSRF和cookies攻击的过程）

[阮一峰老师的DDOS 攻击的防范教程](<http://www.ruanyifeng.com/blog/2018/06/ddos.html>)

<details>
<summary>展开查看</summary> 
    	<ol>DDos 攻击</ol>
    	<li>客户端向服务端发送请求链接数据包</li>
        <li>服务端向客户端发送确认数据包</li>
        <li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li>  
        <ol>DDos 预防( 没有彻底根治的办法，除非不使用TCP )(</ol>
    	<li>限制同时打开SYN半链接的数目</li>
        <li>缩短SYN半链接的Time out 时间</li>
        <li>关闭不必要的服务</li>
        <li>现在可以使用备用网站</li>
</details>



### 27. 分析http发送的网络过程

[http请求](<https://www.cnblogs.com/xiaonantianmen/p/9426118.html>)



### 28. 什么是长连接？长连接有什么缺点？

[HTTP的长连接、短连接 ](<https://www.cnblogs.com/gotodsp/p/6366163.html>)

<details>
<summary>展开查看</summary> 
    <li>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</li>
    <li>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></li>
    <li>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li>
    <li>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</li>
</details>


<details>
<summary>长连接优缺点</summary> 
    <li>优点：长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。</li>
    <li>缺点：在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候</li>
</details>

<details>
<summary>短连接优缺点</summary> 
    <li>优点：短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段</li>
    <li>缺点：如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</li>
</details>

<details>
<summary>长连接短连接操作过程</summary> 
    <li>短连接的操作步骤是：
建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接
</li>
    <li>长连接的操作步骤是：
建立连接——数据传输...（保持连接）...数据传输——关闭连接</li>
</details>


### 29. HTTP管线化。说说管线化的特点。

<details>
<summary>展开查看</summary> 
    <li>在使用持久连接的情况下，某个连接上消息的传递类似于：</li>
    <p>
        请求1 -> 响应1-> 请求2 -> 响应2 - > 请求3 -> 响应3
    </p>
    <li>管线化之后，某个连接上的消息变成了类似这样：</li>
    <p>
        请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3
    </p>
</details>


<details>
<summary>管线化特点</summary> 
    <li>实现了多个http请求不需要等待相应的应答就能够写进同一个socket的技术。管线化需要客户端和服务端双方都支持管线化。</li>
    <li>管线化机制通过持久连接完成，仅HTTP/1.1支持此技术</li>
	<li>只有GET和HEAD请求可以进行管线化，而POST则有所限制</li>
    <li>初次创建连接时不建议启动管线机制，因为服务器不一定支持HTTP/1.1版本的协议</li>
    <li>管线化不会影响响应到来的顺序，响应返回的顺序并未改变</li>
    <li>HTTP/1.1要求服务端必须支持管线化，但并不是要求服务器也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
    <li>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefox默认并未开启管线化支持。</li>
</details>





### 30. 浏览器从输入网址到显示出网页的全过程

<details>
<summary>展开查看</summary> 
    <li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
    <li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
    <li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
    <li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
    <li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
    <li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</details>




### 31. HTTPS怎么确认收到的包就是服务器发来的

<details>
<summary>展开查看</summary> 
        <li>客户端向服务器端发送请求连接</li>
        <li>服务器端将自己公钥发送给CA（证书中心），CA用自己的私钥给服务器端的公钥和其他信息进行加密，并将自己的公钥发送给客户端</li>
    <li>之后服务器端将数字证书发送给客户端，客户端检查数字证书是由有效</li>
    <li>如果有效的话服务端会生成一个随机数R，并使用CA的公钥对R进行加密。</li>
    <li>客户端将加密的R传送给服务器。</li>
    <li>服务器用自己的私钥解密得到R。</li>
    <li>服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。</li>
    <li>客户端以R为密钥使用之前约定好的解密算法获取网页内容。
</li>
</details>




### 32. 输入 [www.baidu.com，怎么变成](http://www.baidu.xn--com%2C-yj5fs80afjwtvd/) [https://www.baidu.com](https://www.baidu.com/) 的，怎么确定用HTTP还是HTTPS

[你访问的网站是如何自动切换到 HTTPS 的？](https://www.sohu.com/a/136637876_487516)

<details>
<summary>展开查看</summary> 
    <p>
       一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 
    </p>
    <p>
        解决方法是引入HSTS（HTTP严格传输安全协议）机制，用户浏览器在访问站点的时候强制使用HTTPS。
    </p>
</details>


### 33. NAT协议详解；

<details>
<summary>展开查看</summary> 
    <p>
       NAT (Network Address Translation, 网络地址转换)。 
    </p>
    <p>
        用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。
    </p>
</details>



### 34. 我去ping一个美国的机器，找不到对方怎么办；

<details>
<summary>展开查看</summary> 
    <p>
       使用VPN(Virtual Private Network)(虚拟专用网络)。VPN的主要功能:在公用网络上建立专用网络，进行加密通讯。
    </p>
    <p>
        VPN的主要目的：是给企业内网直接传输加密数据，最重要的就是安全性
    </p>
    <p>
    	电脑使用VPN后，所有的网络通信都走代理。适合所有场景。VPN控制的是你电脑的整个网络
    </P>
</details>





