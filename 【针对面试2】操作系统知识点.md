[TOC]

## 进程线程协程

### 1. 进程和线程有什么区别？

![1585106229477](https://s1.ax1x.com/2020/03/27/Gio1HA.png)

[阮一峰老师的进程与线程的一个简单解释](<https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html>)

<details>
<summary>展开查看</summary>
    <p>阮一峰老师的解释清晰易懂</p>
    <p>
        CPU相当于一个工厂，时刻在运行，在生产。
    </p>
    <p>
        进程就相当于工厂中的一个车间
    </p>
    <p>
        线程就相当于车间中的很多工人。他们协同完成一个任务。
    </p>
</details>

<details>
<summary>展开查看</summary>
    <li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</li>
    <li><b>线程依赖于进程而存在，一个进程至少有一个线程；</b></li>
    <li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li>
    <li><b>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源</b>，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；</li>
    <li>在<b>进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置</b>，而<b>线程切换只需保存和设置少量的寄存器的内容</b>，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li>
    <li>线程之间的通信更方便，<b>同一进程下的线程共享全局变量等数据</b>，而进程之间的通信需要以进程间通信(IPC)的方式进行；</li>
    <li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此<b>多进程更加健壮</b></li>
</details>



### 2. 同一进程中的线程可以共享哪些数据？

<details>
<summary>展开查看</summary>
    <li>进程代码段</li>
    <li>进程的公有数据（全局变量、静态变量...)</li>
    <li>进程打开的文件描述符</li>
    <li>进程的当前目录</li>
    <li>信号处理器/信号处理函数：对收到的信号的处理方式</li>
    <li>进程ID与进程组ID</li>
</details>



### 3. 线程独占哪些资源？

<details>
<summary>展开查看</summary>
    <li>线程ID</li>
    <li>一组寄存器的值</li>
    <li>线程自身的栈（堆是共享的）</li>
    <li>进程的当前目录</li>
    <li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li>
    <li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li>
</details>





### 4. 进程间通信（IPC）有哪些方式？

[进程间通信方法总结](<https://www.jianshu.com/p/c1015f5ffa74>)

![](https://s1.ax1x.com/2020/03/27/Gijp3n.png)

<details>
<summary>什么是进程间通信</summary>
    <li>每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。</li>
</details>

<details>
<summary>常用的进程间的通信方式</summary>
    <ol>
        <li>无名管道( pipe )：管道是一种<b>半双工</b>的通信方式，数据<b>只能单向流动</b>，而且<b>只能在具有亲缘关系的进程间使用</b>。进程的亲缘关系通常是指父子进程关系。（使用最简单）</li>
        <li>有名管道 (named pipe) ： 有名管道也是<b>半双工</b>的通信方式，但是它<b>允许无亲缘关系进程</b>间的通信。
</li>
        <li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。<b>消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</b>。
</li>
    	<li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。（开销最小）</li>
        <li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
</li>
    	<li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<b>共享内存是最快的 IPC 方式</b>。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；（无血缘关系）</li>
    	<li>套接字：这是一种更为一般得进程间通信机制，它可用于<b>网络中不同机器之间的进程间通信</b>，应用非常广泛。（最稳定）</li>
    </ol>
</details>

详情可看：<https://www.jianshu.com/p/c1015f5ffa74>




### 5. 进程同步问题

> 进程的同步是目的，而进程间通信是实现进程同步的手段

<details>
<summary>管程 Monitor</summary>
    <li>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。</li>
    <li>当一个进程试图进入管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在紧急等待队列中等待。（HOARE管程）</li>
    <li>wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（HOARE管程）</li>
    <li>MESA管程：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换</li>
</details>

<details>
<summary>生产者-消费者问题</summary>
    <li>问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据</li>
    <pre>
    <code>
        # 伪代码描述 
        # 定义信号量 full记录缓冲区物品数量 empty代表缓冲区空位数量 mutex为互斥量
semaphore full = 0, empty = n, mutex = 1;
def producer:
	while 1:
		produce an item in nextp;  //生产数据
        P(empty);  //获取空缓冲区单元
        P(mutex);  //进入临界区.
        add nextp to buffer;  //将数据放入缓冲区
        V(mutex);  //离开临界区,释放互斥信号量
        V(full);  //满缓冲区数加1
def consumer:
	while 1:
		P(full);  //获取满缓冲区单元
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        V (mutex);  //离开临界区，释放互斥信号量
        V (empty) ;  //空缓冲区数加1
        consume the item;  //消费数据
    </code>
    </pre>
</details>

<details>
<summary>哲学家就餐问题</summary>
</details>

<details>
<summary>读者-写者问题</summary>
</details>

#### 5.1 临界区的概念？

<details>
<summary>展开查看</summary>
    <p>
        各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段。
    </p>
</details>

#### 5.2 同步与互斥的概念？

<details>
<summary>展开查看</summary>
    <li>同步：多个进程因为合作而使得进程的执行<b>有一定的先后顺序</b>。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；</li>
    <li>互斥：多个进程在<b>同一时刻只有一个进程能进入临界区</b></li>
</details>

#### 5.3 并发、并行、异步的区别？

<details>
<summary>展开查看</summary>
    <li>并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；（一个CPU上同时运行多个程序）</li>
    <li>多线程：并发运行的一段代码。是实现异步的手段</li>
    <li>并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的（多个CPU同时运行多个程序）</li>
    <li>异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事</li>
</details>


#### 5.4 信号量怎么实现对共享资源的访问

<details>
<summary>展开查看</summary>
    <li>我们定义一个单一的二值信号量，sv，初始值为1并且可以为两个进程所访问。</li>
    <li>一旦一个进程已经执行P(sv)操作，这个进程就可以获得信号量并且进入临界区。</li>
    <li>第二个进程就会被阻止进行临界区，因为当他尝试执行P(sv)时，他就会等待，直到第一个进程离开临界区并且执行V(sv)操作来释放信号量。</li>
</details>




### 6. 进程的三种基本状态

![1585121508064](https://s1.ax1x.com/2020/03/27/GioHC6.png)

<details>
<summary>展开查看</summary>
    <li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源（等待处理机）</li>
    <li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</li>
    <li>阻塞状态：进程等待某种条件，在条件满足之前无法执行（等待输入输出）</li>
</details>









### 7. 进程调度策略有哪些？

1. **批处理系统**：

<details>
<summary>先来先服务 first-come first-serverd（FCFS）</summary>
   <li>队列实现，非抢占的</li>
    <li>按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）</li>
    <li>对短进程不利，对IO密集型进程不利。</li>
</details>

<details>
<summary>最短作业优先 shortest job first（SJF）</summary>
   <li>按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；</li>
    <li>对短进程提供好的响应时间，对长进程不利。</li>
</details>

<details>
<summary>最短剩余时间优先 shortest remaining time next（SRTN）</summary>
   <li>按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。当一个新的作业到达时，新作业的运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。</li>
    <li>吞吐量高，开销可能较大，提供好的响应时间</li>
    <li>可能导致饥饿问题，对长进程不利。</li>
</details>

<details>
<summary>最高响应比优先 Highest Response Ratio Next（HRRN）</summary>
   <li>响应比 = 1+ 等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。</li>
    <li>最高响应比优先综合了短作业优先，先来先服务，以及长作业也能得到服务的特性</li>
</details>

2. **交互式系统**

> 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

<details>
<summary>时间片轮转 Round Robin</summary>
   <li>可抢占的</li>
    <li>
       将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；
    </li>
    <li>
        若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。
    </li>
</details>

<details>
<summary>优先级调度算法</summary>
   <li>可以是抢占的，也可以是非抢占的</li>
   <li>
       为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
    </li>
</details>


<details>
<summary>多级反馈队列调度算法 Multilevel Feedback Queue</summary>
   <li>
       设置多个就绪队列1、2、3...，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。
    </li>
    <li>
        抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。
    </li>
</details>



### 8. 什么叫优先级反转？如何解决？

[什么是优先级反转(翻转)](<https://www.jianshu.com/p/c1f7aa944dda>)

<details>
<summary>展开查看</summary>
    <li>高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。</li>
    <ol>
        解决方法：
        <li>优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li>
        <li>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。</li>
    </ol>
</details>



### 9. 什么是僵尸进程？

<details>
<summary>展开查看</summary>
    <p>
        个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait/waitpid获取子进程的状态信息，那么<b>子进程的进程描述符仍然保存在系统中。</b>这种进程称之为僵死进程。
    </p>
    <p>
        僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。
    </p>
    <p>
        危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。
    </p>
    <ol>
        以下情况不会产生僵尸进程：
        <li>该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</li>
        <li>父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入WNOHANG(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；</li>
        <li>子进程结束时，系统会产生SIGCHLD(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；</li>
        <li>也可以用signal(SIGCLD, SIG_IGN)(signal-ignore)通知内核，表示忽略SIGCHLD信号，那么子进程结束后，内核会进行回收。</li>
    </ol>
</details>



### 10. 什么是孤儿进程？

<details>
<summary>展开查看</summary>
    <li>一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。</li>
    <li>孤儿进程并不会有什么危害。就相当于当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。</li>
</details>



### 11. 线程同步有哪些方式？

> 为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。

<details>
<summary>展开查看</summary>
    <li>互斥量（Synchronized/Lock）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li>
    <li>信号量（Semphare）：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了<b>最大资源计数和当前可用资源计数</b>，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；</li>
    <li>事件(信号)（Event）：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为<b>手动重置事件</b>和<b>自动重置事件</b>。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。
</li>
    <li>临界区（Critical Section）：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>
</details>



### 12. 互斥量和临界区有什么区别？

<details>
<summary>展开查看</summary>
    <li>
        互斥量是可以命名的，可以用于不同进程之间的同步；
    </li>
    <li>而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。</li>
</details>



### 13. 什么是协程？

<details>
<summary>展开查看</summary>
    <li>
        协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
    </li>
    <li>协程拥有自己的寄存器上下文和栈。</li>
    <li>协程是单线程工作，没有多线程需要考虑的同时写变量冲突，所以不需要多线程的锁机制，故执行效率比多线程更高。</li>
    <li>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>
</details>





### 14. 协程多与线程进行比较？

<https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272>

<details>
<summary>展开查看</summary>
    <li>
        一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
    </li>
    <li>线程进程都是同步机制，而协程则是异步</li>
    <li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li>
    <li>加入由协程执行A、B函数，在执行A的时候可以随时中断执行B，又可以返回来执行A。其中的状态都会保留</li>
</details>



### 15. 进程切换时，会发生什么

<details>
<summary>展开查看</summary>
    <li>1.切换页目录以使用新的地址空间</li>
    <li>2.切换内核栈和硬件上下文</li>
    <li>线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。</li>
</details>





### 16. 不同线程的堆栈相同吗。

<details>
<summary>展开查看</summary>
    <li>线程拥有自己的堆栈，和自己的寄存器上下文</li>
    <li>切换时，需要挂起线程，存储被切换线程的堆栈和寄存器上下文，然后设置新的线程的寄存器上下文和堆栈，调整这两个线程的级别。</li>
</details>



### 17. 实现进程同步的机制有什么

<details>
<summary>展开查看</summary>
    <li>无名管道/有名管道</li>
    <li>消息队列</li>
    <li>套接字</li>
    <li>信号</li>
    <li><b>信号量机制</b></li>
    <li>共享内存</li>
</details>




### 18. 进程切换与线程切换区别？

<details>
<summary>展开查看</summary>
    <li>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会</li>
    <li>因为每个进程都有自己的虚拟地址空间,而线程是共享所在进程的虚拟地址空间的,因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</li>
</details>



### 19. 线程进程的区别，线程一般都共用进程的什么资源

<details>
<summary>展开查看</summary>
    <ol>区别
        <li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</li>
    <li><b>线程依赖于进程而存在，一个进程至少有一个线程；</b></li>
    </ol>
    <ol>共用的进程资源
        <li>进程代码段</li>
    <li>进程的公有数据（全局变量、静态变量...)</li>
    <li>进程打开的文件描述符</li>
    <li>进程的当前目录</li>
    <li>信号处理器/信号处理函数：对收到的信号的处理方式</li>
    <li>进程ID与进程组ID</li>
    </ol>
</details>


### 20. 什么是IO多路复用？怎么实现？

[IO模式和IO多路复用](<https://www.cnblogs.com/zingp/p/6863170.html>)

<details>
<summary>展开查看</summary>
    <li>IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。</li>
    <li>文件描述符（File descriptor）一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</li>
    <li>实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。</li>
</details>



### 21. select/poll/epoll三者的区别？

[漫谈五种IO模型（主讲IO多路复用）](<https://www.jianshu.com/p/6a6845464770>)

<details>
<summary>展开查看</summary>
    <li>select：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：<b>每次都要复制，开销大</b>），由内核根据就绪状态修改该集合的内容。（缺点2）<b>集合大小有限制</b>，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：<b>轮询的方式效率较低</b>），当文件描述符的数量增加时，效率会线性下降；（不断轮询去监听的socket，socket个数有限制，一般为1024个）</li>
    <li>poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用<b>链表存储</b>，没有最大存储数量的限制；（采用轮询方式监听，只不过没有个数限制）</li>
    <li>epoll：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，<b>避免了轮询</b>（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。（并不是采用轮询方式去监听了，而是当socket有变化时<b>通过回调的方式主动</b>告知用户进程。）</li>
    <ol>
        总结，区别在于：
        <li>一个线程/进程所能打开的最大连接数</li>
        <li>文件描述符传递方式（是否复制）</li>
        <li>水平触发 or 边缘触发</li>
        <li>查询就绪的描述符时的效率（是否轮询）</li>
    </ol>
</details>




### 22. 什么时候使用select/poll，什么时候使用epoll？

<details>
<summary>展开查看</summary>
   <li>当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；</li>
    <li>但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</li>
</details>



### 23. 什么是文件描述符？

<details>
<summary>展开查看</summary>
   <li>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。<b>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</b></li>
    <li>内核通过文件描述符来访问文件。文件描述符指向一个文件。</li>
</details>




### 24. 什么是水平触发？什么是边缘触发？

<details>
<summary>展开查看</summary>
   <li>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；</li>
    <li>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。</li>
    <li>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li>
    <li>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。</li>
</details>



### 25. 有哪些常见的IO模型？

[漫谈五种IO模型（主讲IO多路复用）](<https://www.jianshu.com/p/6a6845464770>)

<details>
<summary>展开查看</summary>
   <li>同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；</li>
    <li>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；</li>
    <li>IO多路复用：单个进程/线程就可以同时处理多个IO请求。</li>
    <li>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</li>
    <li>信号驱动I/O模型:可以用信号，让内核在描述字就绪时发送SIGIO信号通知我们。</li>
</details>



下面引用知乎一书焚城的回答再次巩固一下IO模型

<details>
<summary>举例说明</summary>
   <p>
       1. 同步阻塞IO（Blocking IO）：给女神发一条短信, 说我来找你了, 然后就默默的<b>一直等着</b>女神下楼, 这个期间除了等待你不会做其他事情, 属于备胎做法.
    </p>
    <p>
        2. 同步非阻塞IO（Non-blocking IO）：给女神发短信, 如果不回, 接着再发, <b>一直发</b>到女神下楼, 这个期间你除了发短信等待不会做其他事情, 属于专一做法.
    </p>
    <ol>3. IO多路复用： 是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么?
        <li>select大妈：每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子</li>
        <li>poll大妈：不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神</li>
        <li>epoll大妈：不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.</li>
        <li>上面这些同步IO有一个共同点就是, 当女神走出宿舍门口的时候, 你已经站在宿舍门口等着女神的, 此时你属于阻塞状态</li>
    </ol>
    <p>
        4. 异步IO（Asynchronous IO）：你告诉女神我来了, 然后你就去王者荣耀了, 一直到女神下楼了, 发现找不见你了, 女神再给你打电话通知你, 说我下楼了, 你在哪呢? 这时候你才来到宿舍门口. 此时属于逆袭做法
    </p>
</details>



### 26. 什么是用户态和内核态？

<details>
<summary>展开查看</summary>
   <p>
       为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。
    </p>
    <li>用户态只能<b>受限地访问内存，且不允许访问外围设备</b>，没有占用CPU的能力，CPU资源可以被其它程序获取；</li>
    <li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
    <p>
        <b>所有用户程序都运行在用户态</b>，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<b>陷阱指令</b>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。
    </p>
</details>




### 27. 为什么要分用户态和内核态？

<details>
<summary>展开查看</summary>
   <li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；</li>
    <li>封装性：用户程序不需要实现更加底层的代码；</li>
    <li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。</li>
</details>



### 28. 如何从用户态切换到内核态？

<details>
<summary>展开查看</summary>
   <li>系统调用：比如读取命令行输入。本质上还是通过中断实现</li>
    <li>用户程序发生异常时：比如缺页异常</li>
    <li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</li>
</details>


### 29. 什么是同步/异步，什么是阻塞/非阻塞

<details>
<summary>展开查看</summary>
   <li>同步：在发出一个功能调用时，在没有得到结果之前，该调用就不返回。场景：A调用B，此时只有等B有结果了才返回。</li>
    <li>异步：当一个异步过程调用发出后，调用者不能立刻得到结果。调用者可以继续向下执行。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。场景：: A调用B，B立即返回，无须等待。当B处理完之后会通过通知或者回调函数的方式来告诉A结果。</li>
    <li>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。（同步是没返回，阻塞是挂起）场景：A调用B，A会被被挂起，一直在等待B的结果，什么事都不能干。</li>
    <li>非阻塞：指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。场景：A调用B，自己不用被挂起等待B的结果，可以去干其他的事情。</li>
</details>

[如果区分不了同步和阻塞的区别，可以看看这篇文章](<https://blog.csdn.net/qq_42405666/article/details/100620374?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task>)

<details>
<summary>展开查看</summary>
   <p>
       同步/异步：针对的被调用者的状态。也就是fun函数。（也就是上面的烧水壶）
    </p>
    <p>
        同步是指fun如果没有结果就不会返回，除非有结果了。
    </p>
    <p>
        异步是指fun在被调用之后就立即返回了。返回结果之后再通知调用者（可以用信号、回调之类的实现）。
    </p>
    <p>
        阻塞/非阻塞：主要是针对调用者的，是指程序在等待结果时的状态。（也就是上面的老张在等水开时的状态）
    </p>
    <p>
        阻塞是指调用线程会被挂起，不做什么别的事情。在得到结果之后才会返回。
    </p>
    <p>
        非阻塞是指不能立即得到结果，当前线程不会被挂起，还可以做别的事情。
    </p>
</details>


### 30. 如何实现一个同步非阻塞的请求

待完成：开另外一个线程？使用AJAX？



## 死锁

### 1. 什么是死锁？

<details>
<summary>展开查看</summary>
    <p>
       在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，（就是每个进程都在等着对方释放，一直等死了😰）在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。
    </p>
</details>



### 2. 死锁产生的必要条件？

<details>
<summary>展开查看</summary>
    <li>互斥：只要有一个资源一次只能被一个进程使用（非共享）；<b>若其他申请使用该资源，那么申请进程必须等到该资源被释放为止</b></li>
    <li>占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li>
    <li>非抢占：已经分配给一个进程的资源<b>不能被强制性抢占</b>，只能由进程完成任务之后自愿释放；</li>
    <li>循环等待：若干进程之间形成一种<b>头尾相接的环形</b>等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。（有环）</li>
</details>



### 3. 死锁有哪些处理方法？

<details>
<summary>鸵鸟策略</summary>
    <p>
        直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
    </p>
</details>

<details>
<summary>死锁预防</summary>
    <ol>
        基本思想是<b>破坏形成死锁的四个必要条件</b>：
        <li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</li>
        <li>破坏占有并等待条件：可以<b>实行资源预先分配策略</b>(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。</li>
        <li>破坏非抢占条件：<b>允许进程强行抢占</b>被其它进程占有的资源。会降低系统性能；</li>
        <li>破坏循环等待条件：<b>对所有资源统一编号</b>，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。</li>
    </ol>
</details>

<details>
<summary>死锁避免</summary>
    <li><b>动态检测</b>资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</li>
    <li>银行家算法:当一个进程申请使用资源的时候，银行家算法通过先<b>试探</b>配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</li>
</details>

<details>
<summary>死锁解除</summary>
    <li>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。</li>
    <ol>死锁解除的方法：
        <li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li>
        <li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；（回到安全状态）</li>
        <li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。（随机选择一个幸运观众）</li>
    </ol>
</details>




## 内存管理

### 1. 分页和分段有什么区别？

<details>
<summary>展开查看</summary>
    <li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>
    <li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>
    <li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>
</details>

<details>
<summary>区别：</summary>
    <li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>
    <li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定（分页技术的粒度更小，能在代码和数据层面换进换出。分段是在用户所写程序中换进换出）</li>
    <li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>
    <li>信息共享：分段便于信息的保护和共享；分页的共享收到限制；</li>
    <li>内存碎片：分段没有内碎片（因为段的大小可变，改变端大小来消除内碎片），但会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）；分页没有外碎片（因为页大小固定），但会产生内碎片（一个页填不满）</li>
</details>

<details>
<summary>举例说明：</summary>
    <li>打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。</li>
    <li>第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。</li>
    <li>第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习</li>
</details>



### 2. 什么是虚拟内存？

<details>
<summary>展开查看</summary>
    <li>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；</li>
    <li>但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。</li>
    <li>这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</li>
    <li>虚拟内存的优点是解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大。</li>
</details>






### 3. 如何进行地址空间到物理内存的映射？

<details>
<summary>展开查看</summary>
    <li><b>内存管理单元</b>（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。</li>
    <li>逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。
</li>
</details>





### 4. 有哪些页面置换算法？

> 在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

<details>
<summary>最佳页面置换算法OPT（Optimal replacement algorithm）</summary>
    <p>
        置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略
    </p>
</details>

<details>
<summary>先进先出FIFO</summary>
    <p>
        置换在内存中驻留时间最长的页面。
    </p>
    <p>
        缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；
    </p>
</details>

<details>
<summary>第二次机会算法SCR</summary>
    <p>
       按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
    </p>
</details>

<details>
<summary>时钟算法 Clock</summary>
    <p>
       SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；
    </p>
</details>

<details>
<summary>最近未使用算法NRU（Not Recently Used）</summary>
    <p>
       检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；
    </p>
</details>

<details>
<summary>最近最少使用算法LRU（Least Recently Used）</summary>
    <p>
       置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
    </p>
</details>

<details>
<summary>最不经常使用算法NFU</summary>
    <p>
       置换出访问次数最少的页面
    </p>
</details>


### 5. 局部性原理

> 局部性原理: CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。
>
> 就是说我们在读取一个内存块的时候将该内存块附近的内存块也读进缓存中

#### 5.1 局部性原理解决的问题

* 主存容量远远比缓存大，CPU执行程序的时候需要使用内存块，如果该内存块在缓存上，那么处理器直接从缓存上取该内存块就行了，因为缓存的数据传输的速率比内存快的多。
* 因为主存容量大，所以要取的内存块很可能不在缓存上，因此就要把这个内存块移到缓存上。局部性原理就是解决这个问题：
  * 时间上：最近被访问的页在不久的将来还会被访问；
  * 空间上：内存中被访问的页周围的页也很可能被访问。(在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。正在使用的这个数据地址旁边的数据，当然也是很可能被用到的。比如数组什么的)





### 6. 什么是颠簸现象

<details>
<summary>展开查看</summary>
    <li>颠簸本质上是指频繁的页调度行为。</li>
    <li>进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。</li>
    <li>因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。</li>
</details>





### 7. 内存颠簸的解决策略

<details>
<summary>展开查看</summary>
    <li>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</li>
    <li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；</li>
    <li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；</li>
</details>


### 8. 虚拟地址到物理地址的映射，页表结构怎么样的

<details>
<summary>展开查看</summary>
    <li>分段和分页可以将虚拟地址转化为物理地址</li>
    <li>页表中有页号和块号。页号记录了虚拟地址的每一页。块号记录了物理地址的内存地址。</li>
    <li>通过查找页表就可以很容易地找到该页在内存中的位置。页表具有逻辑地址到物理地址映射的作用。</li>
</details>

![img](https://s1.ax1x.com/2020/03/27/GiXhAe.png)





## 磁盘调度

过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。



### 1. 寻道时间的调度算法

<details>
<summary>为减小寻道时间的调度算法</summary>
    <li>先来先服务</li>
    <li>最短寻道时间优先</li>
    <li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
</details>




